#!/bin/bash
# raspi-cloud — A TUI for managing the Nextcloud environment (now central script with integrated setup, backup, and restore)

set -euo pipefail

# --- Configuration and Initialization ---
REPO_DIR="/opt/raspi-nextcloud-setup"
LOG_DIR="/var/log/raspi-nextcloud"
MAIN_LOG_FILE="$LOG_DIR/main_setup.log"
BACKUP_LOG_FILE="$LOG_DIR/backup.log"
RESTORE_LOG_FILE="$LOG_DIR/restore.log"
LVM_LOG_FILE="$LOG_DIR/lvm_migration.log"
FLASH_LOG_FILE="$LOG_DIR/flash_to_drive.log"
ENV_FILE="$REPO_DIR/.env"
COMPOSE_FILE="$REPO_DIR/docker-compose.yml"
CRON_FILE="/etc/cron.d/nextcloud-backup"
HEALTH_LOG_FILE="$LOG_DIR/health_check.log"
HEIGHT=20
WIDTH=70
CHOICE_HEIGHT=8
BOOT_PARTITION="/boot/firmware"  # Standard for Pi 5 Bookworm
BACKUP_MOUNTDIR="/mnt/backup"  # Hardcoded mount point

# Detect boot device
root_dev=$(findmnt -o SOURCE / | tail -1 | cut -d'[' -f1)
# Robustly get the parent disk name (e.g., nvme0n1 from /dev/nvme0n1p2 or sda from /dev/sda2)
root_disk_name=$(lsblk -no PKNAME "$root_dev" 2>/dev/null || basename "$root_dev" | sed 's/p[0-9]*$//')

if [[ $root_dev == /dev/mmcblk* ]]; then
    is_sd_boot=true
else
    is_sd_boot=false
fi

# --- Ensure dependencies and scripts are ready (idempotent) ---
if ! command -v dialog >/dev/null 2>&1; then
    echo "Error: 'dialog' is required but not installed." >&2
    exit 1
fi
if ! command -v docker >/dev/null 2>&1; then
    echo "Error: 'docker' is required but not installed." >&2
    exit 1
fi

mkdir -p "$LOG_DIR"

# --- Helper Functions (moved up for availability) ---
update_env() {
    local key="$1" value="$2"
    if grep -q "^$key=" "$ENV_FILE" 2>/dev/null; then
        sed -i "s|^$key=.*|$key=$value|" "$ENV_FILE"
    else
        echo "$key=$value" >> "$ENV_FILE"
    fi
}

# --- Generate .env.template and docker-compose.yml if not present ---
generate_env_template() {
    if [[ ! -f "$REPO_DIR/.env.template" ]]; then
        cat > "$REPO_DIR/.env.template" << 'EOF'
# .env.template
# This file is a template. A final .env file will be generated during setup.

# === Nextcloud Configuration ===
# The primary administrator account for Nextcloud.
NEXTCLOUD_ADMIN_USER=admin
NEXTCLOUD_ADMIN_PASSWORD=changeme

# Space-separated list of domains Nextcloud will trust.
# This is set automatically during setup if using Cloudflare.
NEXTCLOUD_TRUSTED_DOMAINS=cloud.yourdomain.com

# The local port on the Raspberry Pi that maps to Nextcloud's port 80.
NEXTCLOUD_PORT=8080

# === MariaDB Database Configuration ===
# IMPORTANT: Change these default passwords for production.
MYSQL_ROOT_PASSWORD=changeme_root
MYSQL_DATABASE=nextcloud
MYSQL_USER=nextcloud_user
MYSQL_PASSWORD=changeme

# === Directory Configuration ===
# The host path where Nextcloud user data (files, photos, etc.) is stored.
# This should be on a drive with sufficient space (e.g., an external SSD).
NEXTCLOUD_DATA_DIR=/home/user/nextcloud

# === Backup Configuration ===
# The number of old backup archives to keep.
BACKUP_RETENTION=8
# Custom cron schedule fields for backup timing (defaults to weekly on Sunday at 03:00).
# See 'configure_backup_settings' in raspi-cloud for details.
BACKUP_MINUTE=0
BACKUP_HOUR=3
BACKUP_DAY_MONTH=*
BACKUP_MONTH=*
BACKUP_DAY_WEEK=0

# === Cloudflare Tunnel (optional) ===
# The Tunnel ID created by 'cloudflared'. This is set automatically.
CF_TUNNEL_ID=

# Trusted Proxies (for reverse proxy config)
TRUSTED_PROXIES_0=172.18.0.1
TRUSTED_PROXIES_1=127.0.0.1

# === Home Assistant Configuration (optional) ===
HA_PORT=8123
HA_TRUSTED_DOMAINS=
EOF
    fi
}

generate_docker_compose() {
    if [[ ! -f "$COMPOSE_FILE" ]]; then
        cat > "$COMPOSE_FILE" << 'EOF'
services:
  nextcloud:
    image: nextcloud:31-apache # Pinned to a specific major version for stability
    restart: unless-stopped
    ports:
      - "${NEXTCLOUD_PORT}:80"
    volumes:
      - nextcloud_html:/var/www/html
      - ${NEXTCLOUD_DATA_DIR}:/var/www/html/data
    environment:
      - NEXTCLOUD_ADMIN_USER=${NEXTCLOUD_ADMIN_USER}
      - NEXTCLOUD_ADMIN_PASSWORD=${NEXTCLOUD_ADMIN_PASSWORD}
      - NEXTCLOUD_TRUSTED_DOMAINS=${NEXTCLOUD_TRUSTED_DOMAINS}
      - MYSQL_PASSWORD=${MYSQL_PASSWORD}
      - MYSQL_DATABASE=${MYSQL_DATABASE}
      - MYSQL_USER=${MYSQL_USER}
      - MYSQL_HOST=db
    depends_on:
      db:
        condition: service_healthy # Waits for the DB to be ready
    logging:
      driver: "json-file"
      options:
        max-size: "10m"
        max-file: "3"
    healthcheck:
      test: ["CMD-SHELL", "curl -f http://localhost/status.php || exit 1"]
      interval: 30s
      timeout: 10s
      retries: 5
    # deploy: # Optional: Uncomment to limit resources on a Swarm cluster or with 'docker compose --with-deploy'
    #   resources:
    #     limits:
    #       cpus: '1.0'
    #       memory: 1G

  db:
    image: mariadb:11.2 # Pinned to a specific major version
    restart: unless-stopped
    command: --transaction-isolation=READ-COMMITTED --binlog-format=ROW
    volumes:
      - db_data:/var/lib/mysql
    environment:
      - MYSQL_ROOT_PASSWORD=${MYSQL_ROOT_PASSWORD}
      - MYSQL_PASSWORD=${MYSQL_PASSWORD}
      - MYSQL_DATABASE=${MYSQL_DATABASE}
      - MYSQL_USER=${MYSQL_USER}
    logging:
      driver: "json-file"
      options:
        max-size: "10m"
        max-file: "3"
    healthcheck:
      test: ["CMD", "healthcheck.sh", "--su-mysql", "--connect", "--innodb_initialized"]
      interval: 15s
      timeout: 5s
      retries: 5
    # deploy:
    #   resources:
    #     limits:
    #       cpus: '1.0'
    #       memory: 1.5G

volumes:
  nextcloud_html:
  db_data:
EOF
    fi
}

# Generate files on startup
generate_env_template
generate_docker_compose

# --- Helper Functions ---
die() {
    dialog --title "Error" --msgbox "$1" 8 60
    exit 1
}

get_nc_cid() {
    docker compose -f "$COMPOSE_FILE" ps -q nextcloud 2>/dev/null || true
}

is_stack_running() {
    [[ -n "$(get_nc_cid)" ]]
}

wait_for_completion() {
    local pid=$1
    local title=$2
    local text=$3
    while kill -0 "$pid" 2>/dev/null; do
        sleep 1
    done
    wait "$pid"
    return $?
}

reset_terminal() {
    sleep 0.5
    stty sane 2>/dev/null || true
}

# --- Maintenance Mode Helpers ---

# Sets maintenance mode.
# $1: Mode ("--on" or "--off")
# $2: (Optional) Log file to redirect output to
set_maintenance_mode() {
    local mode="$1"
    local log_file="${2:-/dev/null}" # Default to /dev/null if no log file

    if ! is_stack_running; then
        echo "[WARN] Stack not running, cannot set maintenance mode." >> "$log_file"
        return 1
    fi

    local nc_cid
    nc_cid=$(get_nc_cid)
    if [[ -z "$nc_cid" ]]; then
        echo "[WARN] Nextcloud container not found, cannot set maintenance mode." >> "$log_file"
        return 1
    fi

    # Check if container is actually running
    if ! docker inspect --format '{{.State.Running}}' "$nc_cid" 2>/dev/null | grep -q '^true$'; then
         echo "[WARN] Nextcloud container not running, cannot set maintenance mode." >> "$log_file"
         return 1
    fi

    if docker exec -u www-data "$nc_cid" php occ maintenance:mode "$mode" >> "$log_file" 2>&1; then
        echo "[INFO] Maintenance mode set to $mode." >> "$log_file"
        return 0
    else
        echo "[WARN] Failed to set maintenance mode to $mode." >> "$log_file"
        return 1 # Return error
    fi
}

# Gets maintenance mode status
# ECHOES 0 if enabled, 1 if disabled, 2 if error
# Always exits with 0 to prevent script abort (due to set -e)
get_maintenance_status() {
    if ! is_stack_running; then echo 2; return 0; fi # return 0 is for set -e
    local nc_cid
    nc_cid=$(get_nc_cid)
    if [[ -z "$nc_cid" ]]; then echo 2; return 0; fi

    local current_status
    # Capture the output, exit code since it is 0 in both states
    current_status=$(docker exec -u www-data "$nc_cid" php occ maintenance:mode 2>&1)
    if [ $? -ne 0 ]; then
         return 2 # Error querying
    fi
    # Check the text output to determine status
    if echo "$current_status" | grep -q "enabled"; then
        echo 0 # Enabled
    elif echo "$current_status" | grep -q "disabled"; then
        echo 1 # Disabled
    else
        echo 2 # Error
    fi
    
    # Crucially, always exit with success (0)
    return 0
 }

select_backup_drive() {  
    local drives
    mapfile -t drives < <(lsblk -o NAME,TYPE,RM,SIZE,MODEL | awk -v root="$root_disk_name" '$2=="disk" && $1 != root {print "/dev/" $1 " (" $4 ", " $5 ")"}')
    if [ ${#drives[@]} -eq 0 ]; then
        dialog --title "No Drives" --msgbox "No external drives detected. Insert one and try again." 8 50
        return 1
    fi
    local options=()
    for i in "${!drives[@]}"; do
        options+=("$((i+1))" "${drives[$i]}")
    done

    local choice
    choice=$(dialog --stdout --title "Select Backup Drive" --menu "Choose a drive:" $HEIGHT $WIDTH $CHOICE_HEIGHT "${options[@]}")
    if [ $? -ne 0 ]; then return 1; fi

    local selected_dev="/dev/$(echo "${drives[$((choice-1))]}" | awk '{print $1}' | sed 's/\/dev\///')"

    local fs_type
    fs_type=$(blkid -o value -s TYPE "$selected_dev")

    local format_choice=1
    if [[ -n "$fs_type" ]]; then
        dialog --title "Drive Formatted" --yesno "Drive is formatted as $fs_type. Format anyway? (erases all data)" 8 60
        format_choice=$?
    else
        dialog --title "Unformatted Drive" --yesno "Drive is unformatted. Format now? (required to use)" 8 60
        format_choice=$?
    fi

    if [ $format_choice -eq 0 ]; then
        dialog --title "Confirm Format" --yesno "Formatting will ERASE ALL DATA on $selected_dev. Proceed?" 8 60
        if [ $? -ne 0 ]; then return 1; fi
        mkfs.ext4 -F -L "NextcloudBackup" "$selected_dev" >> "$BACKUP_LOG_FILE" 2>&1
        if [ $? -ne 0 ]; then
            dialog --title "Error" --msgbox "Failed to format drive." 8 50
            return 1
        fi
        fs_type="ext4"
    elif [[ -z "$fs_type" ]]; then
        dialog --title "Error" --msgbox "Drive must be formatted to use." 8 50
        return 1
    fi

    local uuid
    uuid=$(blkid -o value -s UUID "$selected_dev")
    if [[ -z "$uuid" ]]; then
        dialog --title "Error" --msgbox "Failed to get UUID." 8 50
        return 1
    fi

    mkdir -p "$BACKUP_MOUNTDIR"

    sed -i "\|$BACKUP_MOUNTDIR|d" /etc/fstab
    echo "UUID=$uuid $BACKUP_MOUNTDIR $fs_type defaults,nofail,x-systemd.device-timeout=10 0 2" >> /etc/fstab

    mount -a >> "$BACKUP_LOG_FILE" 2>&1
    if ! mountpoint -q "$BACKUP_MOUNTDIR"; then
        dialog --title "Error" --msgbox "Failed to mount drive." 8 50
        return 1
    fi

    dialog --title "Success" --msgbox "Backup drive configured and mounted at $BACKUP_MOUNTDIR." 8 50
    return 0
}

# --- Integrated Setup Function (from setup script) ---
setup() {
    echo "--- setup script started ---"

    set -euo pipefail

    # --- Constants ---
    readonly REPO_DIR="/opt/raspi-nextcloud-setup"
    readonly ENV_FILE="$REPO_DIR/.env"
    readonly ENV_TEMPLATE="$REPO_DIR/.env.template"
    readonly COMPOSE_FILE="$REPO_DIR/docker-compose.yml"
    readonly LOCK_FILE="/var/run/raspi-nextcloud-setup.lock"
    readonly REQUIRED_CMDS=("curl" "git" "jq" "parted" "lsblk" "blkid" "docker" "cloudflared" "gpg")

    # --- Helper Functions ---
    die() { echo "[ERROR] $1" >&2; exit 1; }

    wait_for_healthy() {
        local service_name="$1"
        local timeout_seconds="$2"
        local container_id
        echo "Waiting for $service_name to become healthy..."
        container_id=$(docker compose -f "$COMPOSE_FILE" ps -q "$service_name" 2>/dev/null)
        [[ -z "$container_id" ]] && die "Could not find container for service '$service_name'."
        local end_time=$((SECONDS + timeout_seconds))
        while [ $SECONDS -lt $end_time ]; do
            local status
            status=$(docker inspect --format="{{if .State.Health}}{{.State.Health.Status}}{{end}}" "$container_id" 2>/dev/null || echo "inspecting")
            [ "$status" == "healthy" ] && { echo "✅ $service_name is healthy."; return 0; }
            sleep 5
        done
        die "$service_name did not become healthy. Check logs: 'docker logs $container_id'."
    }

    # --- Main Logic ---
    preflight_checks() {
        echo "[*] Running pre-flight checks..."
        [[ $EUID -ne 0 ]] && die "This script must be run as root."

        if [[ -z "${SUDO_USER-}" ]]; then
            die "Could not determine the original user. Please run with 'sudo' (e.g., 'sudo raspi-cloud'), not via 'sudo su' or a root shell."
        fi

        for cmd in "${REQUIRED_CMDS[@]}"; do
            if ! command -v "$cmd" &>/dev/null; then
                [[ "$cmd" == "curl" || "$cmd" == "git" ]] && die "Required command '$cmd' is not installed."
            fi
        done
        cd "$REPO_DIR"
        USER_HOME=$(eval echo "~$SUDO_USER")
        [[ -d "$USER_HOME" ]] || die "Could not determine home directory for user '$SUDO_USER'."
    }

    install_dependencies() {
        echo "[1/10] Installing system dependencies..."
        apt-get install -y ca-certificates curl gnupg lsb-release cron jq moreutils parted gpg

        # Docker setup (idempotent)
        if ! [ -f /etc/apt/keyrings/docker.gpg ]; then
            mkdir -p /etc/apt/keyrings
            curl -fsSL https://download.docker.com/linux/debian/gpg | gpg --dearmor -o /etc/apt/keyrings/docker.gpg
            echo "deb [arch=$(dpkg --print-architecture) signed-by=/etc/apt/keyrings/docker.gpg] https://download.docker.com/linux/debian $(lsb_release -cs) stable" > /etc/apt/sources.list.d/docker.list
            apt-get update -y
        fi
        apt-get install -y docker-ce docker-ce-cli containerd.io docker-compose-plugin

        # Ensure Docker is running
        systemctl enable --now docker
        if ! systemctl is-active --quiet docker; then
            die "Docker failed to start. Check systemctl status docker."
        fi
        if ! [ -f /usr/share/keyrings/cloudflared.gpg ]; then
            mkdir -p --mode=0755 /usr/share/keyrings
            curl -fsSL https://pkg.cloudflare.com/cloudflare-main.gpg | gpg --dearmor -o /usr/share/keyrings/cloudflared.gpg
            echo "deb [signed-by=/usr/share/keyrings/cloudflared.gpg] https://pkg.cloudflare.com/cloudflared $(lsb_release -cs) main" > /etc/apt/sources.list.d/cloudflared.list
            apt-get update -y
        fi
        apt-get install -y cloudflared
    }

    gather_config_from_env() {
        echo "[2/10] Gathering configuration from environment..."
        : "${NEXTCLOUD_ADMIN_PASSWORD:?}" "${MYSQL_ROOT_PASSWORD:?}" "${MYSQL_PASSWORD:?}" "${BASE_DOMAIN:?}"
        SUBDOMAIN=${SUBDOMAIN:-nextcloud}
        CF_HOSTNAME="$SUBDOMAIN.$BASE_DOMAIN"
        NEXTCLOUD_TRUSTED_DOMAINS="$CF_HOSTNAME"
        NEXTCLOUD_ADMIN_USER="admin"
        MYSQL_USER="nextcloud_user"
        MYSQL_DATABASE="nextcloud"
        USER_HOME=$(eval echo "~$SUDO_USER")
        NEXTCLOUD_DATA_DIR="$USER_HOME/nextcloud"
        NEXTCLOUD_PORT="8080"
        BACKUP_RETENTION=8
        # New: Trusted proxies from env or default
        TRUSTED_PROXIES_0="${TRUSTED_PROXIES_0:-172.18.0.1}"
        TRUSTED_PROXIES_1="${TRUSTED_PROXIES_1:-127.0.0.1}"
    }

    generate_env_file() {
        echo "[4/10] Generating .env configuration file..."
        [[ -f "$ENV_TEMPLATE" ]] || die "Missing .env.template file."

        if [[ ! -f "$ENV_FILE" ]]; then
            cp "$ENV_TEMPLATE" "$ENV_FILE"
        fi

        update_env "NEXTCLOUD_ADMIN_USER" "$NEXTCLOUD_ADMIN_USER"
        update_env "NEXTCLOUD_ADMIN_PASSWORD" "$NEXTCLOUD_ADMIN_PASSWORD"
        update_env "NEXTCLOUD_TRUSTED_DOMAINS" "$NEXTCLOUD_TRUSTED_DOMAINS"
        update_env "NEXTCLOUD_PORT" "$NEXTCLOUD_PORT"
        update_env "MYSQL_ROOT_PASSWORD" "$MYSQL_ROOT_PASSWORD"
        update_env "MYSQL_DATABASE" "$MYSQL_DATABASE"
        update_env "MYSQL_USER" "$MYSQL_USER"
        update_env "MYSQL_PASSWORD" "$MYSQL_PASSWORD"
        update_env "NEXTCLOUD_DATA_DIR" "$NEXTCLOUD_DATA_DIR"
        update_env "BACKUP_RETENTION" "$BACKUP_RETENTION"
        update_env "CF_TUNNEL_ID" "$CF_TUNNEL_ID"
        update_env "TRUSTED_PROXIES_0" "$TRUSTED_PROXIES_0"
        update_env "TRUSTED_PROXIES_1" "$TRUSTED_PROXIES_1"

        # Validate key vars
        grep -q "NEXTCLOUD_ADMIN_PASSWORD=$NEXTCLOUD_ADMIN_PASSWORD" "$ENV_FILE" || die "Failed to update .env (admin password)."
        grep -q "CF_TUNNEL_ID=$CF_TUNNEL_ID" "$ENV_FILE" || die "Failed to update .env (tunnel ID)."

        chmod 600 "$ENV_FILE"
    }

    deploy_docker_stack() {
        echo "[5/10] Deploying Docker stack, may take a while..."
        docker compose --env-file "$ENV_FILE" -f "$COMPOSE_FILE" pull
        docker compose --env-file "$ENV_FILE" -f "$COMPOSE_FILE" up -d --remove-orphans
        wait_for_healthy "db" 120
        wait_for_healthy "nextcloud" 600
    }

    configure_nextcloud_https() {
        echo "[6/10] Applying reverse proxy HTTPS configuration..."
        local NC_CID
        NC_CID=$(docker compose -f "$COMPOSE_FILE" ps -q nextcloud)
        [[ -z "$NC_CID" ]] && die "Nextcloud container not ready."

        docker exec --user www-data "$NC_CID" php occ config:system:set overwriteprotocol --value=https || die "Failed to set overwriteprotocol."
        docker exec --user www-data "$NC_CID" php occ config:system:set trusted_proxies 0 --value="$TRUSTED_PROXIES_0" || die "Failed to set trusted_proxies 0."
        docker exec --user www-data "$NC_CID" php occ config:system:set trusted_proxies 1 --value="$TRUSTED_PROXIES_1" || die "Failed to set trusted_proxies 1."
        docker exec --user www-data "$NC_CID" php occ config:system:set trusted_domains 1 --value="$NEXTCLOUD_TRUSTED_DOMAINS" || die "Failed to set trusted_domains 1."
        echo "Restarting Nextcloud service..."
        docker compose -f "$COMPOSE_FILE" restart nextcloud
        wait_for_healthy "nextcloud" 120
    }

    validate_setup() {
        echo "[10/10] Validating setup..."
        sleep 10
        if curl -f -k "https://$CF_HOSTNAME/status.php" >/dev/null 2>&1; then
            echo "✅ Nextcloud is accessible at: https://$CF_HOSTNAME"
        else
            echo "⚠️ Setup complete, but accessibility check failed. Check Cloudflare tunnel and firewall."
        fi
    }

    # --- Function Entry (replaces original main) ---
    exec 200>"$LOCK_FILE"
    flock -n 200 || die "Setup script is already running."
    trap 'rm -f "$LOCK_FILE"; echo "Lock cleaned up." >&2' EXIT
    
    preflight_checks
    install_dependencies
    gather_config_from_env
    generate_env_file
    deploy_docker_stack
    configure_nextcloud_https
    validate_setup

    echo "✅ Installation complete!"
}

backup() {
    set -euo pipefail

    # --- Configuration and Initialization ---
    REPO_DIR="/opt/raspi-nextcloud-setup"
    ENV_FILE="$REPO_DIR/.env"
    LOCK_FILE="/var/run/nextcloud-backup.lock"
    [[ -f "$ENV_FILE" ]] || { echo "Missing $ENV_FILE"; exit 1; }
    # shellcheck disable=SC1090
    source "$ENV_FILE"

    # Validate required variables
    : "${BACKUP_RETENTION:?BACKUP_RETENTION not set in .env}"
    : "${NEXTCLOUD_DATA_DIR:?NEXTCLOUD_DATA_DIR not set}"
    : "${MYSQL_USER:?}"
    : "${MYSQL_PASSWORD:?}"
    : "${MYSQL_DATABASE:?}"

    auto_mount_backup() {
        if mountpoint -q "$BACKUP_MOUNTDIR"; then return 0; fi
        mount "$BACKUP_MOUNTDIR" >> "$BACKUP_LOG_FILE" 2>&1 || {
            echo "[!] Failed to mount $BACKUP_MOUNTDIR. Ensure drive is connected." >> "$BACKUP_LOG_FILE"
            exit 1
        }
    }

    # --- Locking ---
    exec 200>"$LOCK_FILE"
    flock -n 200 || { echo "Backup is already running."; exit 1; }

    # --- Staging and Cleanup ---
    DATE="$(date +'%Y-%m-%d_%H-%M-%S')"
    STAGING_DIR=$(mktemp -d -p "$BACKUP_MOUNTDIR" staging_XXXXXX)  # Secure temp
    ARCHIVE_PATH="$BACKUP_MOUNTDIR/nextcloud_backup_${DATE}.tar.gz"

    # TRAP to ensure cleanup and maintenance mode is turned off on exit/error
    cleanup() {
        echo "[*] Cleaning up... Ensuring maintenance mode is disabled."
        set_maintenance_mode "--off" "$BACKUP_LOG_FILE" || true # Suppress errors
        # Remove staging directory
        if [[ -d "$STAGING_DIR" ]]; then
            rm -rf "$STAGING_DIR"
            echo "[*] Staging directory removed."
        fi
        rm -f "$LOCK_FILE"  # Ensure lock release
    }
    trap cleanup EXIT INT TERM

    # --- Mount Backup Drive ---
    auto_mount_backup

    # --- Main Backup Logic ---
    echo "=== Starting Nextcloud Backup: $DATE ==="

    mkdir -p "$STAGING_DIR/data" "$STAGING_DIR/db" "$STAGING_DIR/config"
    NC_CID="$(docker compose -f "$REPO_DIR/docker-compose.yml" ps -q nextcloud)"
    DB_CID="$(docker compose -f "$REPO_DIR/docker-compose.yml" ps -q db)"

    # Enhanced container checks
    if [[ -z "$NC_CID" ]] || ! docker inspect --format '{{.State.Running}}' "$NC_CID" 2>/dev/null | grep -q '^true$'; then
        echo "[!] Nextcloud container not found or not running. Aborting."
        exit 1
    fi
    if [[ -z "$DB_CID" ]] || ! docker inspect --format '{{.State.Running}}' "$DB_CID" 2>/dev/null | grep -q '^true$'; then
        echo "[!] DB container not found or not running. Aborting."
        exit 1
    fi

    echo "[1/6] Checking for sufficient disk space..."
    ESTIMATED_DATA_KB=$(du -sk "$NEXTCLOUD_DATA_DIR" | awk '{print $1}')
    # Dynamically estimate DB size (fallback to 100MB if query fails)
    ESTIMATED_DB_KB=$(docker exec "$DB_CID" mariadb -u "$MYSQL_USER" -p"$MYSQL_PASSWORD" -e "SELECT ROUND(SUM(data_length + index_length) / 1024) AS size_kb FROM information_schema.tables WHERE table_schema='$MYSQL_DATABASE';" 2>/dev/null | tail -1 || echo "102400")
    ESTIMATED_CONFIG_KB=51200  # Conservative for config (50MB)
    ESTIMATED_UNCOMPRESSED_KB=$((ESTIMATED_DATA_KB + ESTIMATED_DB_KB + ESTIMATED_CONFIG_KB))
    # Peak: ~2.0x for staging + archive (assuming no compression; adjust multiplier if needed)
    ESTIMATED_PEAK_KB=$((ESTIMATED_UNCOMPRESSED_KB * 2))
    AVAILABLE_KB=$(df --output=avail "$BACKUP_MOUNTDIR" | tail -n1)
    echo "[INFO] Estimated uncompressed: $((ESTIMATED_UNCOMPRESSED_KB / 1024)) MB, Peak: $((ESTIMATED_PEAK_KB / 1024)) MB, Available: $((AVAILABLE_KB / 1024)) MB" >> "$BACKUP_LOG_FILE"
    if [ "$AVAILABLE_KB" -lt "$ESTIMATED_PEAK_KB" ]; then
        echo "[!] Not enough free space. Available: $((AVAILABLE_KB / 1024)) MB, Needed (peak): $((ESTIMATED_PEAK_KB / 1024)) MB. Aborting."
        exit 1
    fi

    echo "[2/6] Enabling maintenance mode..."
    set_maintenance_mode "--on" "$BACKUP_LOG_FILE" || die "Failed to enable maintenance mode."

    echo "[3/6] Dumping database..."
    docker run --rm \
      --network container:"$DB_CID" \
      -e MYSQL_PWD="$MYSQL_PASSWORD" \
      mysql:8 \
      mysqldump --column-statistics=0 -h 127.0.0.1 -u "$MYSQL_USER" "$MYSQL_DATABASE" \
      > "$STAGING_DIR/db/nextcloud.sql"

    echo "[4/6] Copying data and config..."
    if ! rsync -a --delete "$NEXTCLOUD_DATA_DIR"/ "$STAGING_DIR/data/" 2>> "$BACKUP_LOG_FILE"; then
        echo "[!] Rsync failed. Check permissions or disk space." >> "$BACKUP_LOG_FILE"
        exit 1
    fi
    NC_HTML_VOLUME=$(docker inspect "$NC_CID" --format '{{ range .Mounts }}{{ if eq .Destination "/var/www/html" }}{{ .Name }}{{ end }}{{ end }}')
    docker run --rm -v "${NC_HTML_VOLUME}:/volume:ro" -v "$STAGING_DIR/config":/backup alpine \
        sh -c "cp -a /volume/config/. /backup/"

    echo "[5/6] Creating compressed archive..."
    if ! tar -C "$STAGING_DIR" -czf "$ARCHIVE_PATH" data db config 2>> "$BACKUP_LOG_FILE"; then
        echo "[!] Tar failed (possibly out of space). Partial archive may exist: $ARCHIVE_PATH" >> "$BACKUP_LOG_FILE"
        rm -f "$ARCHIVE_PATH"  # Clean partial file idempotently
        exit 1
    fi
    sync

    # Maintenance mode is disabled by the 'trap cleanup' function

    echo "[6/6] Applying backup retention policy (keep last $BACKUP_RETENTION)..."
    OLD_BACKUPS=$(ls -tp "$BACKUP_MOUNTDIR"/nextcloud_backup_*.tar.gz 2>/dev/null | tail -n +$((BACKUP_RETENTION+1)))
    if [[ -n "$OLD_BACKUPS" ]]; then
        echo "[INFO] Deleting old backups: $OLD_BACKUPS" >> "$BACKUP_LOG_FILE"
    fi
    ls -tp "$BACKUP_MOUNTDIR"/nextcloud_backup_*.tar.gz 2>/dev/null | tail -n +$((BACKUP_RETENTION+1)) | xargs -r rm --
    echo "--- Backup Complete: $ARCHIVE_PATH ---"
    rm -f "$LOCK_FILE"  # Redundant lock release for idempotence
}

restore() {
    set -euo pipefail

    # --- Configuration and Initialization ---
    REPO_DIR="/opt/raspi-nextcloud-setup"
    ENV_FILE="$REPO_DIR/.env"
    COMPOSE_FILE="$REPO_DIR/docker-compose.yml"
    [[ -f "$ENV_FILE" ]] || { echo "Missing $ENV_FILE"; exit 1; }
    # shellcheck disable=SC1090
    source "$ENV_FILE"

    # --- Helper Functions ---

    # Print a formatted error message and exit.
    die() {
        echo "[ERROR] $1" >&2
        exit 1
    }

    # Helper function to wait for a container to be healthy using `docker inspect`.
    wait_for_healthy() {
        local service_name="$1"
        local timeout_seconds="$2"
        local container_id

        echo "Waiting for $service_name to become healthy..."
        
        container_id=$(docker compose -f "$COMPOSE_FILE" ps -q "$service_name" 2>/dev/null)
        if [[ -z "$container_id" ]]; then
            die "Could not find container for service '$service_name'. Please check Docker logs."
        fi

        local end_time=$((SECONDS + timeout_seconds))
        while [ $SECONDS -lt $end_time ]; do
            local status
            # Directly inspect the health status from Docker's metadata.
            status=$(docker inspect --format="{{if .State.Health}}{{.State.Health.Status}}{{end}}" "$container_id" 2>/dev/null || echo "inspecting")
            if [ "$status" == "healthy" ]; then
                echo "✅ $service_name is healthy."
                return 0
            fi
            sleep 5
        done

        die "$service_name container did not become healthy in time. Check logs with 'docker logs $container_id'."
    }

    # Validate required variables
    : "${NEXTCLOUD_DATA_DIR:?NEXTCLOUD_DATA_DIR not set}"
    : "${MYSQL_USER:?}"
    : "${MYSQL_PASSWORD:?}"
    : "${MYSQL_DATABASE:?}"
    : "${MYSQL_ROOT_PASSWORD:?}"

    # --- Temporary Directory and Cleanup ---
    TMP_DIR=$(mktemp -d -t nextcloud-restore-XXXXXX)
    trap 'echo "[*] Cleaning up temporary directory..."; rm -rf "$TMP_DIR"' EXIT INT TERM

    # --- Mount Backup Drive ---
    mkdir -p "$BACKUP_MOUNTDIR"
    if ! mountpoint -q "$BACKUP_MOUNTDIR"; then
      mount "$BACKUP_MOUNTDIR" || {
        echo "[!] Failed to mount $BACKUP_MOUNTDIR. Aborting."
        exit 1
      }
    fi

    # --- Handle --no-prompt flag ---
    no_prompt=false
    for arg in "$@"; do
        if [[ "$arg" == "--no-prompt" ]]; then
            no_prompt=true
        fi
    done

    # --- Select Backup File ---
    if [[ $# -ge 1 && "$1" != "--no-prompt" ]]; then
      BACKUP_FILE="$1"
    else
      echo "[*] No backup file specified. Finding the latest..."
      BACKUP_FILE="$(find "$BACKUP_MOUNTDIR" -maxdepth 1 -name 'nextcloud_backup_*.tar.gz' -print0 | xargs -0 ls -t | head -n1)"
      [[ -n "$BACKUP_FILE" ]] || { echo "No backups found in $BACKUP_MOUNTDIR"; exit 1; }
    fi
    [[ -f "$BACKUP_FILE" ]] || { echo "Backup not found: $BACKUP_FILE"; exit 1; }
    echo "[*] Selected backup for restore: $BACKUP_FILE"

    # --- User Confirmation ---
    echo "!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! WARNING !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!"
    echo "This will COMPLETELY OVERWRITE the following:"
    echo "  - Nextcloud data: $NEXTCLOUD_DATA_DIR"
    echo "  - Nextcloud config"
    echo "  - MariaDB database: $MYSQL_DATABASE"
    echo "This operation is irreversible."
    if $no_prompt; then
        CONFIRM="OVERWRITE"
    else
        read -rp "Type 'OVERWRITE' to proceed: " CONFIRM
    fi
    [[ "${CONFIRM^^}" == "OVERWRITE" ]] || { echo "Restore aborted by user."; exit 0; }

    # --- Main Restore Logic ---
    echo "[1/6] Stopping and removing Nextcloud container..."
    docker compose -f "$REPO_DIR/docker-compose.yml" rm -sf nextcloud

    echo "[2/6] Extracting backup to temporary location..."
    tar -xzf "$BACKUP_FILE" -C "$TMP_DIR"
    [[ -d "$TMP_DIR/data" && -f "$TMP_DIR/db/nextcloud.sql" && -d "$TMP_DIR/config" ]] || \
      { echo "Backup archive is malformed (missing data/, db/, or config/ dirs)."; exit 1; }

    echo "[3/6] Restoring data and config directories..."
    mkdir -p "$NEXTCLOUD_DATA_DIR"
    rsync -a --delete "$TMP_DIR/data/" "$NEXTCLOUD_DATA_DIR/"
    # Get volume name idempotently (even if container is stopped)
    NC_HTML_VOLUME=$(docker volume ls -q -f name=raspi-nextcloud-setup_nextcloud_html)
    docker run --rm -v "${NC_HTML_VOLUME}:/volume" -v "$TMP_DIR/config:/backup:ro" alpine \
        sh -c "rm -rf /volume/config/* && cp -a /backup/. /volume/config/"

    echo "[4/6] Resetting and restoring database..."
    docker compose -f "$REPO_DIR/docker-compose.yml" up -d db
    echo "[*] Waiting for DB container to be healthy..."
    wait_for_healthy "db" 120
    DB_CID="$(docker compose -f "$REPO_DIR/docker-compose.yml" ps -q db)"
    NETWORK_NAME=$(docker inspect "$DB_CID" --format='{{range $k, $v := .NetworkSettings.Networks}}{{$k}}{{end}}')

    # Drop and recreate database to ensure idempotent restore
    docker run --rm \
      --network "$NETWORK_NAME" \
      -e MYSQL_PWD="$MYSQL_ROOT_PASSWORD" \
      mysql:8 \
      sh -c "mysql -h db -u root -e \"DROP DATABASE IF EXISTS $MYSQL_DATABASE; CREATE DATABASE $MYSQL_DATABASE;\""

    # Import dump using mysql:8 client container
    docker run --rm \
      --network "$NETWORK_NAME" \
      -e MYSQL_PWD="$MYSQL_ROOT_PASSWORD" \
      -v "$TMP_DIR/db/nextcloud.sql:/restore.sql" \
      mysql:8 \
      sh -c "mysql -h db -u root $MYSQL_DATABASE < /restore.sql"

    echo "[5/6] Starting Nextcloud service..."
    docker compose -f "$REPO_DIR/docker-compose.yml" up -d nextcloud

    echo "[6/6] Verifying services and exiting maintenance mode..."
    echo "[*] Waiting for Nextcloud container to be healthy..."
    wait_for_healthy "nextcloud" 180
    NC_CID_NEW="$(docker compose -f "/opt/raspi-nextcloud-setup/docker-compose.yml" ps -q nextcloud)"
    docker exec -u www-data "$NC_CID_NEW" php occ maintenance:mode --off || true

    # Temp dir is cleaned up by the trap
    echo "=== Restore Complete From: $BACKUP_FILE ==="
}

# --- Argument Parsing for Non-Interactive Modes (e.g., cron) ---
if [ $# -gt 0 ]; then
    case "$1" in
        --backup)
            backup
            exit $?
            ;;
        --restore)
            shift
            restore "$@"
            exit $?
            ;;
    esac
fi

install_backup_cron() {
    local minute="$1" hour="$2" day_of_month="$3" month="$4" day_of_week="$5"
    local cron_expr="$minute $hour $day_of_month $month $day_of_week"

    local cron_content="# Run Nextcloud backup at $cron_expr\n$cron_expr root /usr/local/sbin/raspi-cloud --backup >> $BACKUP_LOG_FILE 2>&1\n"
    if [[ -f "$CRON_FILE" && $(cat "$CRON_FILE") == *"$cron_expr"* ]]; then
        echo "Cron job already up-to-date for schedule $cron_expr."
    else
        echo -e "$cron_content" > "$CRON_FILE"
        chmod 644 "$CRON_FILE"
        echo "Cron job updated for schedule $cron_expr."
    fi
}

system_health_check() {
    touch "$HEALTH_LOG_FILE"
    chmod 644 "$HEALTH_LOG_FILE"

    (
        echo "=== System Health Check Started at $(date) ==="

        # Docker status
        echo "[CHECK] Docker service:"
        if systemctl is-active --quiet docker; then
            echo "  ✅ Docker is running"
        else
            echo "  ❌ Docker is not running"
        fi

        # Stack status
        echo "[CHECK] Nextcloud stack:"
        if is_stack_running; then
            echo "  ✅ Stack is running"
            local nc_cid db_cid
            nc_cid=$(get_nc_cid)
            db_cid=$(docker compose -f "$COMPOSE_FILE" ps -q db 2>/dev/null)
            if [[ -n "$nc_cid" && -n "$db_cid" ]]; then
                local nc_health db_health
                nc_health=$(docker inspect --format="{{if .State.Health}}{{.State.Health.Status}}{{end}}" "$nc_cid" 2>/dev/null || echo "unknown")
                db_health=$(docker inspect --format="{{if .State.Health}}{{.State.Health.Status}}{{end}}" "$db_cid" 2>/dev/null || echo "unknown")
                echo "  Nextcloud health: $nc_health"
                echo "  DB health: $db_health"
            fi
        else
            echo "  ❌ Stack is not running"
        fi

        # Disk space
        echo "[CHECK] Disk usage:"
        df -h / | tail -1 | awk '{print "  Root: " $5 " used (" $4 " available)"}'
        source "$ENV_FILE" 2>/dev/null || true
        local backup_dir="$BACKUP_MOUNTDIR"
        if mountpoint -q "$backup_dir"; then
            df -h "$backup_dir" | tail -1 | awk '{print "  Backup: " $5 " used (" $4 " available)"}'
        else
            echo "  Backup dir not mounted"
        fi

        # Backup drive mount
        echo "[CHECK] Backup drive:"
        if mountpoint -q "$backup_dir"; then
            echo "  ✅ Mounted at $backup_dir"
        else
            echo "  ❌ Not mounted"
        fi

        # Cron job
        echo "[CHECK] Backup cron:"
        if [[ -f "$CRON_FILE" ]]; then
            echo "  ✅ Installed: $(head -1 "$CRON_FILE")"
        else
            echo "  ❌ Not installed"
        fi

        # Log errors (last 50 lines)
        echo "[CHECK] Recent errors in logs:"
        grep -i "error\|fail\|warn" "$MAIN_LOG_FILE" "$BACKUP_LOG_FILE" "$RESTORE_LOG_FILE" 2>/dev/null | tail -20 || echo "  No recent errors"

        # Nextcloud occ status (if running)
        if [[ -n "$nc_cid" ]]; then
            echo "[CHECK] Nextcloud status:"
            docker exec -u www-data "$nc_cid" php occ status 2>/dev/null || echo "  Could not get status."
        fi

        echo "=== Health Check Completed at $(date) ==="
    ) >> "$HEALTH_LOG_FILE" 2>&1

    dialog --title "System Health Check" --textbox "$HEALTH_LOG_FILE" 25 80
}

# --- Maintenance Menu ---
maintenance_menu() {
    while true; do
        local choice
        choice=$(dialog --stdout \
            --title "Maintenance Menu" \
            --menu "Select an action (or 0 to return):" $HEIGHT $WIDTH $CHOICE_HEIGHT \
            1 "Toggle Maintenance Mode" \
            2 "Scan User Files (files:scan)" \
            3 "Expand Filesystem with LVM" \
            4 "Configure Watchdog" \
            5 "Disable Wireless (WiFi/Bluetooth)" \
            0 "Back to Main Menu")
        local retval=$?
        if [ $retval -ne 0 ] || [ "$choice" = "0" ]; then
            return 0  # Explicit back or cancel -> return to main
        fi

        case "$choice" in
            1) toggle_maintenance_mode ;;
            2) run_files_scan ;;
            3) lvm_storage_extension ;;
            4) configure_watchdog ;;
            5) disable_wireless ;;
        esac
        reset_terminal  # Clean after actions
    done
}

toggle_maintenance_mode() {
    if ! is_stack_running; then
        dialog --title "Error" --msgbox "Nextcloud stack is not running." 8 50
        return 1
    fi

    local current_status
    current_status=$(get_maintenance_status)

    local status
    case "$current_status" in
        0) status="enabled" ;;
        1) status="disabled" ;;
        *)
            dialog --title "Error" --msgbox "Failed to query maintenance mode." 8 50
            return 1
            ;;
    esac

    local new_mode new_status
    if [[ "$status" == "enabled" ]];
    then
        new_mode="--off"
        new_status="disabled"
    else
        new_mode="--on"
        new_status="enabled"
    fi

    dialog --title "Confirm" --yesno "Maintenance mode is currently $status. Do you want to turn it $new_status?" 10 60
    if [ $? -eq 0 ];
    then
        if set_maintenance_mode "$new_mode" >/dev/null 2>&1;
        then
            dialog --title "Success" --msgbox "Maintenance mode is now $new_status." 8 40
        else
            dialog --title "Error" --msgbox "Failed to toggle maintenance mode." 8 50
        fi
    fi
    reset_terminal
}

run_files_scan() {
    if ! is_stack_running; then
        dialog --title "Error" --msgbox "Nextcloud stack is not running." 8 50
        return 1
    fi
    
    local user
    user=$(dialog --stdout \
        --inputbox "Enter username to scan (or '--all' for all users):" 8 60 "")
    local retval=$?
    if [ $retval -ne 0 ] || [ -z "$user" ]; then
        return 0
    fi

    dialog --title "Confirm Scan" --yesno "Scan files for user: '$user'?" 8 50
    if [ $? -eq 0 ]; then
        local nc_cid
        nc_cid=$(get_nc_cid)
        if [[ -z "$nc_cid" ]]; then
            dialog --title "Error" --msgbox "Nextcloud container not found." 8 50
            return 1
        fi
        (
            echo "=== File Scan Started at $(date) ===" 
            docker exec -u www-data "$nc_cid" php occ files:scan "$user"
            echo "=== File Scan Completed at $(date) ===" 
        ) >> "$MAIN_LOG_FILE" 2>&1 &  # Append to preserve history
        local pid=$!
        
        dialog --title "File Scan Log" --tailbox "$MAIN_LOG_FILE" 25 80 &
        local tail_pid=$!
        
        wait_for_completion "$pid" "Scan in Progress" "Scanning user files... (Check log for details)"
        kill "$tail_pid" 2>/dev/null || true
        reset_terminal
        
        dialog --title "Complete" --msgbox "File scan for '$user' finished. Check log for details." 8 60
    fi
}

get_ssd_drives() {
    lsblk -d -o NAME -n | grep -E '^(nvme[0-9]+n[0-9]+|sd[a-z])$' | sort
}

ensure_cloudflare_repo() {
    local log_file="$1"
    echo "Ensuring Cloudflare repository is correctly configured for the current OS..." >> "$log_file"

    # Idempotently add or update the repository
    if [ ! -f /usr/share/keyrings/cloudflared.gpg ]; then
        mkdir -p --mode=0755 /usr/share/keyrings >> "$log_file" 2>&1
        curl -fsSL https://pkg.cloudflare.com/cloudflare-main.gpg | gpg --dearmor -o /usr/share/keyrings/cloudflared.gpg >> "$log_file" 2>&1 || {
            echo "Warning: Failed to add Cloudflare GPG key." >> "$log_file"
        }
    fi

    local current_codename
    current_codename=$(lsb_release -cs)
    local repo_file="/etc/apt/sources.list.d/cloudflared.list"

    if [ -f "$repo_file" ]; then
        # Check and update codename if necessary
        if ! grep -q "$current_codename" "$repo_file"; then
            echo "Updating codename in $repo_file to $current_codename..." >> "$log_file"
            sed -i "s/ [a-z]\+ main/ $current_codename main/" "$repo_file" >> "$log_file" 2>&1 || {
                echo "Warning: Failed to update codename in $repo_file." >> "$log_file"
            }
        else
            echo "Cloudflare repository codename is already correct." >> "$log_file"
        fi
    else
        # Add the repository if it doesn't exist
        echo "Adding Cloudflare repository..." >> "$log_file"
        echo "deb [signed-by=/usr/share/keyrings/cloudflared.gpg] https://pkg.cloudflare.com/cloudflared $current_codename main" | tee "$repo_file" >> "$log_file" 2>&1 || {
            echo "Warning: Failed to add Cloudflare repository." >> "$log_file"
        }
    fi

    # Note: apt update should be called after this function if needed
}

# New: Flash OS to NVMe and Switch Boot (For Fresh SD to NVMe)
flash_to_nvme() {
    local root_dev
    root_dev=$(findmnt -o SOURCE / | tail -1 | cut -d'[' -f1)
    if [[ $root_dev != /dev/mmcblk* ]]; then
        die "This option is only available when booted from SD card."
    fi

    local drives
    drives=$(get_ssd_drives)
    mapfile -t drive_array <<< "$drives"
    if [ ${#drive_array[@]} -eq 0 ]; then
        die "No target SSD/NVMe drive detected."
    fi

    local target_name
    if [ ${#drive_array[@]} -eq 1 ]; then
        target_name=${drive_array[0]}
    else
        local options=()
        for i in "${!drive_array[@]}"; do
            local size
            size=$(lsblk -d -o SIZE -n /dev/"${drive_array[$i]}")
            options+=("$((i+1))" "${drive_array[$i]} ($size)")
        done
        local choice
        choice=$(dialog --stdout --title "Select Target Drive" --menu "Choose the drive to flash to:" 15 50 5 "${options[@]}")
        if [ $? -ne 0 ]; then return 0; fi
        target_name=${drive_array[$((choice-1))]}
    fi

    local part_suffix
    if [[ $target_name =~ ^nvme ]]; then part_suffix="p"; else part_suffix=""; fi
    local target_root_part="/dev/${target_name}${part_suffix}2"

    dialog --title "Warning" --yesno "This will clone the current OS from SD to /dev/$target_name, set boot priority, and reboot. The drive will be overwritten. Proceed?" 10 60
    if [ $? -ne 0 ]; then return 0; fi

    (
        echo "=== Flash to $target_name Started at $(date) ===" >> "$FLASH_LOG_FILE"

        ensure_cloudflare_repo "$FLASH_LOG_FILE"
        apt update >> "$FLASH_LOG_FILE" 2>&1 || die "apt update failed."
        apt install -y git rsync >> "$FLASH_LOG_FILE" 2>&1 || die "Failed to install dependencies."
        git clone https://github.com/geerlingguy/rpi-clone.git /tmp/rpi-clone >> "$FLASH_LOG_FILE" 2>&1 || die "Failed to clone rpi-clone."
        cd /tmp/rpi-clone
        sudo cp rpi-clone rpi-clone-setup /usr/local/bin >> "$FLASH_LOG_FILE" 2>&1 || die "Failed to copy rpi-clone scripts."
        sudo chmod +x /usr/local/bin/rpi-clone /usr/local/bin/rpi-clone-setup >> "$FLASH_LOG_FILE" 2>&1 || die "Failed to make rpi-clone executable."
        rpi-clone "$target_name" -f -U -v >> "$FLASH_LOG_FILE" 2>&1 || die "Clone failed."
        
        # Add auto-start TUI on first boot
        mkdir -p /mnt/target
        mount "$target_root_part" /mnt/target >> "$FLASH_LOG_FILE" 2>&1 || die "Failed to mount new root."
        echo "if [ -f /first_boot_tui ]; then sudo raspi-cloud; rm /first_boot_tui; fi" >> /mnt/target/etc/rc.local
        touch /mnt/target/first_boot_tui
        umount /mnt/target

        # Set boot order
        local boot_code
        if [[ $target_name =~ ^nvme ]]; then boot_code=B3; else boot_code=B2; fi
        raspi-config nonint do_boot_order "$boot_code" >> "$FLASH_LOG_FILE" 2>&1 || die "Failed to set boot order."

        echo "=== Flash to $target_name Completed at $(date) ===" >> "$FLASH_LOG_FILE"
    ) & 
    local pid=$!

    dialog --title "Flash Log" --tailbox "$FLASH_LOG_FILE" 25 80 &
    local tail_pid=$!

    wait_for_completion "$pid" "Flash to Drive in Progress" "Cloning and configuring... (Check log)"
    kill "$tail_pid" 2>/dev/null || true
    reset_terminal

    dialog --title "Complete" --yesno "Flash done. Reboot to $target_name now? (Remove SD card after shutdown)" 8 60
    if [ $? -eq 0 ]; then sudo reboot; fi

    dialog --title "Flash Log" --textbox "$FLASH_LOG_FILE" 25 80
}

# New: LVM Storage Extension Function (Phase-Aware, Automated)
lvm_storage_extension() {
    local drives
    drives=$(get_ssd_drives)
    mapfile -t drive_array <<< "$drives"
    if [ ${#drive_array[@]} -ne 2 ]; then
        die "Exactly two SSD/NVMe drives required for LVM extension."
    fi

    local root_dev_full
    root_dev_full=$(findmnt -no SOURCE /)
    local root_dev_short=${root_dev_full#/dev/mapper/} # Get clean name like rpi--vg-root--lv

    dialog --title "Warning" --yesno "This will extend storage with LVM across two drives, creating a single large filesystem. This process is complex and involves multiple reboots. Ensure you have a fresh Raspberry Pi OS Bookworm Lite SD card available for the intermediate step. It is highly recommended to back up all data first. Proceed?" 15 70
    if [ $? -ne 0 ]; then return 0; fi

    (
        echo "=== LVM Migration Started at $(date) on root: $root_dev_full ===" >> "$LVM_LOG_FILE"

        # --- Phase 1: Preparation on the initial (non-LVM) SSD/NVMe drive ---
        if [[ "$root_dev_full" =~ ^/dev/(nvme|sd) ]]; then
            echo "[Phase 1] Preparing the initial drive for migration..." >> "$LVM_LOG_FILE"
            local current_root_drive
            current_root_drive=$(lsblk -no pkname "$root_dev_full")
            local other_drive=""
            for drive in "${drive_array[@]}"; do
                if [[ "$drive" != "$current_root_drive" ]]; then
                    other_drive=$drive
                    break
                fi
            done
            [[ -z "$other_drive" ]] && die "Could not determine the other drive for initramfs preparation."

            echo "Current root drive: $current_root_drive. The other drive is: $other_drive." >> "$LVM_LOG_FILE"

            ensure_cloudflare_repo "$LVM_LOG_FILE"
            apt update >> "$LVM_LOG_FILE" 2>&1 || die "apt update failed."
            apt install -y lvm2 initramfs-tools rsync parted >> "$LVM_LOG_FILE" 2>&1 || die "Failed to install dependencies."
            sed -i 's/^MODULES=.*/MODULES=most/' /etc/initramfs-tools/initramfs.conf
            # Add required modules for LVM on NVMe/USB
            cat <<EOF >> /etc/initramfs-tools/modules
nvme_core
nvme
dm-mod
usb_storage
sd_mod
EOF
            sort -u /etc/initramfs-tools/modules -o /etc/initramfs-tools/modules
            mkdir -p /etc/initramfs-tools/scripts/local-top
            # Dynamically create the initramfs script to wait for the correct secondary drive
            cat <<EOF > /etc/initramfs-tools/scripts/local-top/force_lvm
#!/bin/sh
PREREQ=""
prereqs() { echo "\$PREREQ"; }
case "\$1" in prereqs) prereqs; exit 0;; esac
. /scripts/functions
modprobe -q nvme_core >/dev/null 2>&1
modprobe -q nvme >/dev/null 2>&1
modprobe -q dm-mod >/dev/null 2>&1
log_begin_msg "Waiting for secondary drive ($other_drive) up to 30s"
for i in \$(seq 1 30); do
    if [ -b /dev/$other_drive ]; then
        log_success_msg "Secondary drive found after \$i seconds"
        break
    fi
    sleep 1
done
lvm pvscan --cache
lvm vgscan --mknodes
lvm vgchange -ay rpi-vg || true
EOF
            chmod +x /etc/initramfs-tools/scripts/local-top/force_lvm
            update-initramfs -u -k "$(uname -r)" >> "$LVM_LOG_FILE" 2>&1 || die "Failed to update initramfs."
            cp "/boot/initrd.img-$(uname -r)" "$BOOT_PARTITION/" || die "Failed to copy initrd."
            if ! grep -q "initramfs initrd.img-$(uname -r) followkernel" "$BOOT_PARTITION/config.txt"; then
                echo -e "\n[all]" >> "$BOOT_PARTITION/config.txt"
                echo "initramfs initrd.img-$(uname -r) followkernel" >> "$BOOT_PARTITION/config.txt"
            fi
            echo "[Phase 1 Complete] System prepared for migration from SD card." >> "$LVM_LOG_FILE"

        # --- Phase 2: Migration performed from a temporary SD card OS ---
        elif [[ "$root_dev_full" == /dev/mmcblk* ]]; then
            echo "[Phase 2] Migrating from original drive to new LVM volume..." >> "$LVM_LOG_FILE"
            
            # Robustly identify source and target drives by checking for a filesystem on partition 2
            local source_drive="" target_drive=""
            local source_suffix target_suffix
            for drive in "${drive_array[@]}"; do
                suffix=$( [[ $drive =~ ^nvme ]] && echo "p" || echo "" )
                if blkid "/dev/${drive}${suffix}2" &>/dev/null; then
                    source_drive=$drive
                    source_suffix=$suffix
                else
                    target_drive=$drive
                    target_suffix=$suffix
                fi
            done
            [[ -z "$source_drive" || -z "$target_drive" ]] && die "Could not identify source or target drive."
            echo "Source drive: $source_drive, Target drive: $target_drive" >> "$LVM_LOG_FILE"

            local original_root_partuuid
            original_root_partuuid=$(blkid -o value -s PARTUUID "/dev/${source_drive}${source_suffix}2")
            [[ -z "$original_root_partuuid" ]] && die "Could not determine PARTUUID of source drive /dev/${source_drive}${source_suffix}2."

            ensure_cloudflare_repo "$LVM_LOG_FILE"
            apt update >> "$LVM_LOG_FILE" 2>&1 || die "apt update failed."
            apt install -y lvm2 rsync parted >> "$LVM_LOG_FILE" 2>&1 || die "Failed to install dependencies."
            
            echo "Setting up LVM on target drive $target_drive..." >> "$LVM_LOG_FILE"
            # Clean up and create LVM on the target drive
            vgremove -f rpi-vg 2>/dev/null || true
            pvremove -f "/dev/$target_drive" 2>/dev/null || true
            wipefs -a "/dev/$target_drive" >> "$LVM_LOG_FILE" 2>&1
            parted --script "/dev/$target_drive" mklabel gpt >> "$LVM_LOG_FILE" 2>&1
            pvcreate -f "/dev/$target_drive" >> "$LVM_LOG_FILE" 2>&1 || die "Failed to create PV on $target_drive."
            vgcreate rpi-vg "/dev/$target_drive" >> "$LVM_LOG_FILE" 2>&1 || die "Failed to create VG 'rpi-vg'."
            lvcreate -n root-lv -l 100%FREE rpi-vg >> "$LVM_LOG_FILE" 2>&1 || die "Failed to create LV 'root-lv'."
            mkfs.ext4 -L rootfs /dev/rpi-vg/root-lv >> "$LVM_LOG_FILE" 2>&1 || die "Failed to format LV."
            
            echo "Copying data from $source_drive to LVM..." >> "$LVM_LOG_FILE"
            mkdir -p /mnt/old_root /mnt/new_root
            mount "/dev/${source_drive}${source_suffix}2" /mnt/old_root >> "$LVM_LOG_FILE" 2>&1 || die "Failed to mount old root."
            mount /dev/rpi-vg/root-lv /mnt/new_root >> "$LVM_LOG_FILE" 2>&1 || die "Failed to mount new LVM root."
            rsync -aAXv --delete /mnt/old_root/ /mnt/new_root/ >> "$LVM_LOG_FILE" 2>&1 || die "Rsync failed."
            
            echo "Configuring boot files for LVM..." >> "$LVM_LOG_FILE"
            mount "/dev/${source_drive}${source_suffix}1" "/mnt/new_root$BOOT_PARTITION" >> "$LVM_LOG_FILE" 2>&1 || die "Failed to mount boot partition."
            # Update fstab and cmdline.txt to point to the new LVM root device
            sed -i "s|PARTUUID=$original_root_partuuid|/dev/mapper/rpi--vg-root--lv|" /mnt/new_root/etc/fstab || die "fstab update failed."
            sed -i "s|root=PARTUUID=[^ ]*|root=/dev/mapper/rpi--vg-root--lv rootfstype=ext4 rootwait|" "/mnt/new_root$BOOT_PARTITION/cmdline.txt" || die "cmdline update failed."
            
            umount "/mnt/new_root$BOOT_PARTITION"
            umount /mnt/new_root
            umount /mnt/old_root
            echo "[Phase 2 Complete] Set boot to the original source drive ($source_drive) via raspi-config, remove SD, and reboot." >> "$LVM_LOG_FILE"

        # --- Phase 3: Finalization on the new LVM root filesystem ---
        elif [[ "$root_dev_short" == "rpi--vg-root--lv" ]]; then
            echo "[Phase 3] Finalizing LVM setup by incorporating the original drive..." >> "$LVM_LOG_FILE"
            
            # Get current PVs
            mapfile -t pvs_list < <(pvs --noheadings -o pv_name | awk '{print $1}')
            
            # Find the partition or whole disk to add (not in current PVs)
            local add_dev=""
            for drive in "${drive_array[@]}"; do
                local suffix=$( [[ $drive =~ ^nvme ]] && echo "p" || echo "" )
                local candidate_dev="/dev/${drive}${suffix}2"
                if [ -b "$candidate_dev" ] && ! printf '%s\n' "${pvs_list[@]}" | grep -q "^$candidate_dev$"; then
                    add_dev="$candidate_dev"
                    break
                fi
                # Check whole disk if partition not present
                candidate_dev="/dev/$drive"
                if [ -b "$candidate_dev" ] && ! printf '%s\n' "${pvs_list[@]}" | grep -q "^$candidate_dev$"; then
                    add_dev="$candidate_dev"
                    break
                fi
            done
            [[ -z "$add_dev" ]] && { echo "No suitable device found to add to VG. Skipping Phase 3." >> "$LVM_LOG_FILE"; return 0; }
            echo "Device to add to LVM: $add_dev" >> "$LVM_LOG_FILE"

            ensure_cloudflare_repo "$LVM_LOG_FILE"
            apt update >> "$LVM_LOG_FILE" 2>&1 || die "apt update failed."
            apt install -y lvm2 parted >> "$LVM_LOG_FILE" 2>&1 || die "Failed to install lvm2."
            
            echo "Wiping and adding $add_dev to volume group..." >> "$LVM_LOG_FILE"
            umount "$add_dev" 2>/dev/null || true
            wipefs -a -f "$add_dev" >> "$LVM_LOG_FILE" 2>&1 || die "Wipefs failed on $add_dev."
            pvcreate -f "$add_dev" >> "$LVM_LOG_FILE" 2>&1 || die "PV create failed on $add_dev."
            vgextend rpi-vg "$add_dev" >> "$LVM_LOG_FILE" 2>&1 || die "VG extend failed."
            
            echo "Extending logical volume and resizing filesystem..." >> "$LVM_LOG_FILE"
            lvextend -l +100%FREE /dev/rpi-vg/root-lv >> "$LVM_LOG_FILE" 2>&1 || die "LV extend failed."
            resize2fs /dev/rpi-vg/root-lv >> "$LVM_LOG_FILE" 2>&1 || die "Resize failed."
            e2fsck -f -y /dev/rpi-vg/root-lv >> "$LVM_LOG_FILE" 2>&1 || true
            echo "[Phase 3 Complete] Storage has been successfully extended across both drives." >> "$LVM_LOG_FILE"

        else
            die "Unknown root device: $root_dev_full. Cannot determine LVM migration phase. Aborting."
        fi

        echo "=== LVM Migration Phase Completed at $(date) ===" >> "$LVM_LOG_FILE"
    ) &
    local pid=$!

    dialog --title "LVM Log" --tailbox "$LVM_LOG_FILE" 25 80 &
    local tail_pid=$!

    wait_for_completion "$pid" "LVM Extension in Progress" "Processing phase... (Check log for details)"
    kill "$tail_pid" 2>/dev/null || true
    reset_terminal

    # --- Phase-specific prompts for next steps ---
    if [[ "$root_dev_full" =~ ^/dev/(nvme|sd) ]]; then
        dialog --title "Next Steps: Reboot to SD Card" --msgbox "Phase 1 is complete. Please perform the following steps:\n\n1. Shut down the Raspberry Pi.\n2. Insert an SD card flashed with a fresh Raspberry Pi OS Lite (Bookworm).\n3. Boot from the SD card (you may need to set this in raspi-config or the bootloader).\n4. On the SD card OS, run the installer again (curl... | sudo bash install.txt).\n5. Run this TUI again and select 'Maintenance' > 'Expand Filesystem with LVM' to begin Phase 2." 18 75
    elif [[ "$root_dev_full" == /dev/mmcblk* ]]; then
        local boot_drive
        boot_drive=$(echo "$LVM_LOG_FILE" | grep "Source drive:" | tail -1 | awk '{print $3}')
        local boot_type="USB Boot (B2)"
        [[ "$boot_drive" =~ ^nvme ]] && boot_type="NVMe/PCIe Boot (B3)"
        dialog --title "Next Steps: Reboot to LVM" --msgbox "Phase 2 is complete. Please perform the following steps:\n\n1. Shut down the Raspberry Pi.\n2. REMOVE the SD card.\n3. Ensure the boot order is set to '$boot_type' (via raspi-config or bootloader).\n4. Power on the device. It will boot from the new LVM volume.\n5. Once booted, run this TUI again and select 'Maintenance' > 'Expand Filesystem with LVM' to begin the final phase." 18 75
    elif [[ "$root_dev_short" == "rpi--vg-root--lv" ]]; then
        dialog --title "Complete" --yesno "LVM extension is complete! The root filesystem is now extended across both drives. It's recommended to reboot to ensure everything is working correctly. Reboot now?" 10 60
        if [ $? -eq 0 ]; then sudo reboot; fi
    fi

    dialog --title "LVM Extension Log" --textbox "$LVM_LOG_FILE" 25 80
}

# --- Configure Watchdog ---
configure_watchdog() {
    dialog --title "Configure Watchdog" --yesno "This will enable the Raspberry Pi's hardware watchdog to automatically reboot the system if it hangs, improving robustness.\n\nSteps:\n- Add dtparam=watchdog=on to boot config (if not present)\n- Install watchdog package (if not installed)\n- Configure /etc/watchdog.conf\n- Enable and start the watchdog service\n\nA reboot is recommended after configuration.\n\nProceed?" 18 70
    if [ $? -ne 0 ]; then
        return 0
    fi

    local log_file="$LOG_DIR/watchdog_config.log"
    touch "$log_file"
    chmod 644 "$log_file"

    (
        set -euo pipefail
        echo "--- Watchdog Configuration Started at $(date) ---" >> "$log_file"

        # Step 1: Enable hardware watchdog in boot config (idempotent)
        local config_file="$BOOT_PARTITION/config.txt"
        if [ ! -f "$config_file" ]; then
            echo "Error: Boot config file not found at $config_file." >> "$log_file"
            exit 1
        fi
        if ! grep -q "^dtparam=watchdog=on" "$config_file"; then
            echo "dtparam=watchdog=on" >> "$config_file"
            echo "Added dtparam=watchdog=on to $config_file" >> "$log_file"
        else
            echo "dtparam=watchdog=on already present in $config_file" >> "$log_file"
        fi

        # Step 2: Install watchdog package (idempotent)
        apt-get update -y >> "$log_file" 2>&1
        if ! dpkg -s watchdog >/dev/null 2>&1; then
            apt-get install -y watchdog >> "$log_file" 2>&1
            echo "Installed watchdog package" >> "$log_file"
        else
            echo "Watchdog package already installed" >> "$log_file"
        fi

        # Step 3: Configure /etc/watchdog.conf (idempotent)
        local conf_file="/etc/watchdog.conf"
        if [ ! -f "$conf_file" ]; then
            echo "Error: $conf_file not found after installation." >> "$log_file"
            exit 1
        fi
        # Uncomment watchdog-device
        sed -i 's/^#watchdog-device/watchdog-device/' "$conf_file"
        # Add or update other settings
        local settings=(
            "watchdog-timeout = 15"
            "interval = 10"
            "realtime = yes"
        )
        for setting in "${settings[@]}"; do
            local key="${setting%% =*}"
            if grep -q "^$key" "$conf_file"; then
                sed -i "s/^$key.*/$setting/" "$conf_file"
                echo "Updated $key in $conf_file" >> "$log_file"
            else
                echo "$setting" >> "$conf_file"
                echo "Added $setting to $conf_file" >> "$log_file"
            fi
        done

        # Step 4: Enable and start service (idempotent)
        systemctl enable watchdog >> "$log_file" 2>&1 || true
        systemctl start watchdog >> "$log_file" 2>&1 || true
        if systemctl is-active --quiet watchdog; then
            echo "Watchdog service is active" >> "$log_file"
        else
            echo "Error: Failed to start watchdog service" >> "$log_file"
            exit 1
        fi

        echo "--- Watchdog Configuration Completed at $(date) ---" >> "$log_file"
    ) & 
    local pid=$!

    dialog --title "Watchdog Configuration Log" --tailbox "$log_file" 25 80 &
    local tail_pid=$!

    wait $pid
    local exit_code=$?
    kill "$tail_pid" 2>/dev/null || true
    reset_terminal

    if [ $exit_code -eq 0 ]; then
        dialog --title "Success" --msgbox "Watchdog configured successfully. A reboot is required for hardware changes to take effect." 8 60
        dialog --title "Reboot" --yesno "Reboot now?" 8 50
        if [ $? -eq 0 ]; then
            sudo reboot
        fi
    else
        dialog --title "Error" --msgbox "Watchdog configuration failed. Check log at $log_file." 8 60
    fi
}

# --- Disable Wireless ---
disable_wireless() {
    dialog --title "Disable Wireless" --yesno "This will disable WiFi and Bluetooth to maximize power efficiency.\n\nSteps:\n- Add dtoverlay=disable-wifi and dtoverlay=disable-bt to boot config (if not present)\n- Install rfkill package (if not installed)\n- Block WiFi and Bluetooth immediately via rfkill\n\nA reboot is recommended for changes to take full effect.\n\nProceed?" 18 70
    if [ $? -ne 0 ]; then
        return 0
    fi

    local log_file="$LOG_DIR/wireless_disable.log"
    touch "$log_file"
    chmod 644 "$log_file"

    (
        set -euo pipefail
        echo "--- Wireless Disable Started at $(date) ---" >> "$log_file"

        # Step 1: Add overlays to boot config (idempotent)
        local config_file="$BOOT_PARTITION/config.txt"
        if [ ! -f "$config_file" ]; then
            echo "Error: Boot config file not found at $config_file." >> "$log_file"
            exit 1
        fi
        if ! grep -q "^dtoverlay=disable-wifi" "$config_file"; then
            echo "dtoverlay=disable-wifi" >> "$config_file"
            echo "Added dtoverlay=disable-wifi to $config_file" >> "$log_file"
        else
            echo "dtoverlay=disable-wifi already present in $config_file" >> "$log_file"
        fi
        if ! grep -q "^dtoverlay=disable-bt" "$config_file"; then
            echo "dtoverlay=disable-bt" >> "$config_file"
            echo "Added dtoverlay=disable-bt to $config_file" >> "$log_file"
        else
            echo "dtoverlay=disable-bt already present in $config_file" >> "$log_file"
        fi

        # Step 2: Install rfkill package (idempotent)
        apt-get update -y >> "$log_file" 2>&1
        if ! dpkg -s rfkill >/dev/null 2>&1; then
            apt-get install -y rfkill >> "$log_file" 2>&1
            echo "Installed rfkill package" >> "$log_file"
        else
            echo "rfkill package already installed" >> "$log_file"
        fi

        # Step 3: Immediately block WiFi and Bluetooth
        rfkill block wifi >> "$log_file" 2>&1 || echo "Warning: Failed to block WiFi (may already be disabled)" >> "$log_file"
        rfkill block bluetooth >> "$log_file" 2>&1 || echo "Warning: Failed to block Bluetooth (may already be disabled)" >> "$log_file"
        echo "Blocked WiFi and Bluetooth via rfkill" >> "$log_file"

        # Step 4: Unload modules if loaded (for immediate effect)
        modprobe -r brcmfmac 2>> "$log_file" || true
        modprobe -r hci_uart 2>> "$log_file" || true
        modprobe -r bluetooth 2>> "$log_file" || true
        echo "Unloaded wireless modules if present" >> "$log_file"

        echo "--- Wireless Disable Completed at $(date) ---" >> "$log_file"
    ) & 
    local pid=$!

    dialog --title "Wireless Disable Log" --tailbox "$log_file" 25 80 &
    local tail_pid=$!

    wait $pid
    local exit_code=$?
    kill "$tail_pid" 2>/dev/null || true
    reset_terminal

    if [ $exit_code -eq 0 ]; then
        dialog --title "Success" --msgbox "Wireless disabled successfully. A reboot is recommended for full effect." 8 60
        dialog --title "Reboot" --yesno "Reboot now?" 8 50
        if [ $? -eq 0 ]; then
            sudo reboot
        fi
    else
        dialog --title "Error" --msgbox "Wireless disable failed. Check log at $log_file." 8 60
    fi
}

# --- Logs Menu ---
logs_menu() {
    while true; do
        local choice
        choice=$(dialog --stdout \
            --title "View Logs" \
            --menu "Select a log to view (or 0 to return):" $HEIGHT $WIDTH $CHOICE_HEIGHT \
            0 "Back to Main Menu" \
            1 "Main Setup Log" \
            2 "Backup Log" \
            3 "Restore Log" \
            4 "Docker Compose Logs" \
            5 "Health Check Log" \
            6 "LVM Migration Log" \
            7 "Flash to Drive Log")
        local retval=$?
        if [ $retval -ne 0 ] || [ "$choice" = "0" ]; then
            return 0
        fi
        
        case "$choice" in
            1) dialog --title "Setup Log" --tailbox "$MAIN_LOG_FILE" 25 80 ;;
            2) dialog --title "Backup Log" --tailbox "$BACKUP_LOG_FILE" 25 80 ;;
            3) dialog --title "Restore Log" --tailbox "$RESTORE_LOG_FILE" 25 80 ;;
            4) 
                local temp_log
                temp_log=$(mktemp)
                if docker compose -f "$COMPOSE_FILE" logs --tail=100 > "$temp_log" 2>&1; then
                    dialog --title "Docker Logs" --tailbox "$temp_log" 25 80
                else
                    dialog --title "Error" --msgbox "Failed to fetch Docker logs." 8 50
                fi
                rm -f "$temp_log"
                ;;
            5) dialog --title "Health Check Log" --tailbox "$HEALTH_LOG_FILE" 25 80 ;;
            6) dialog --title "LVM Log" --tailbox "$LVM_LOG_FILE" 25 80 ;;
            7) dialog --title "Flash Log" --tailbox "$FLASH_LOG_FILE" 25 80 ;;
        esac
        reset_terminal
    done
}

# --- Configure Backup Settings ---
configure_backup_settings() {
    source "$ENV_FILE" 2>/dev/null || true
    local current_retention="${BACKUP_RETENTION:-8}"
    local current_minute="${BACKUP_MINUTE:-0}"
    local current_hour="${BACKUP_HOUR:-3}"
    local current_dom="${BACKUP_DAY_MONTH:-*}"
    local current_month="${BACKUP_MONTH:-*}"
    local current_dow="${BACKUP_DAY_WEEK:-0}"

    # Handle backup drive mounting and configuration
    if mountpoint -q "$BACKUP_MOUNTDIR"; then
        : # Already mounted, proceed
    else
        mount -a >> "$BACKUP_LOG_FILE" 2>&1
        if mountpoint -q "$BACKUP_MOUNTDIR"; then
            : # Mounted successfully, proceed
        else
            dialog --title "Backup Drive" --yesno "Backup drive not mounted. Would you like to configure it now?" 8 60
            if [ $? -eq 0 ]; then
                select_backup_drive || return 0
            else
                dialog --title "Warning" --msgbox "Cannot configure backups without a mounted drive." 8 50
                return 0
            fi
        fi
    fi

    local values
    values=$(dialog --backtitle "Backup Configuration" \
        --stdout \
        --title "Configure Backup Settings" \
        --form "Enter backup settings:" \
        18 60 10 \
        "Retention (Max backups to keep):" 1 1 "$current_retention" 1 20 10 0 \
        "Cron Minute (0-59):" 2 1 "$current_minute" 2 20 10 0 \
        "Cron Hour (0-23):" 3 1 "$current_hour" 3 20 10 0 \
        "Cron Day of Month (1-31):" 4 1 "$current_dom" 4 20 10 0 \
        "Cron Month (1-12):" 5 1 "$current_month" 5 20 10 0 \
        "Cron Day of Week (0-6):" 6 1 "$current_dow" 6 20 10 0)
    local retval=$?
    if [ $retval -ne 0 ] || [ -z "$values" ]; then
        return 0
    fi

    mapfile -t values_array <<< "$values"
    local new_retention="${values_array[0]}"
    local new_minute="${values_array[1]}"
    local new_hour="${values_array[2]}"
    local new_dom="${values_array[3]}"
    local new_month="${values_array[4]}"
    local new_dow="${values_array[5]}"

    update_env "BACKUP_RETENTION" "$new_retention"
    update_env "BACKUP_MINUTE" "$new_minute"
    update_env "BACKUP_HOUR" "$new_hour"
    update_env "BACKUP_DAY_MONTH" "$new_dom"
    update_env "BACKUP_MONTH" "$new_month"
    update_env "BACKUP_DAY_WEEK" "$new_dow"

    install_backup_cron "$new_minute" "$new_hour" "$new_dom" "$new_month" "$new_dow"
}

# --- Run Initial Setup ---
run_initial_setup() {
    # Check if stack is already running (idempotent: warn on re-run)
    if is_stack_running; then
        dialog --title "Warning" --yesno "Stack is already running. Re-run setup? (May reset config)" 8 50
        [[ $? -ne 0 ]] && return
    fi

    local values
    values=$(dialog --backtitle "Nextcloud Initial Setup" \
        --stdout \
        --title "Configuration" \
        --form "Enter your configuration details below." \
        25 60 16 \
        "Admin Password:"   1 1 ""            1 25 40 0 \
        "DB Root Password:" 2 1 ""            2 25 40 0 \
        "DB User Password:" 3 1 ""            3 25 40 0 \
        "Base Domain:"      4 1 "example.com" 4 25 40 0 \
        "Subdomain:"        5 1 "nextcloud"   5 25 40 0)
    local retval=$?
    if [ $retval -ne 0 ] || [ -z "$values" ]; then
        echo "[INFO] User canceled or dialog failed at $(date)" >> "$MAIN_LOG_FILE"
        return 1
    fi

    mapfile -t values_array <<< "$values"
    if [ "${#values_array[@]}" -lt 5 ]; then
        dialog --title "Input Error" --msgbox "All fields are required. Please try again." 8 50
        return 1
    fi

    local ADMIN_PASS="${values_array[0]}"
    local DB_ROOT_PASS="${values_array[1]}"
    local DB_USER_PASS="${values_array[2]}"
    local BASE_DOMAIN="${values_array[3]}"
    local SUBDOMAIN="${values_array[4]}"

    # Safeguard empty vars
    if [[ -z "$ADMIN_PASS" || -z "$DB_ROOT_PASS" || -z "$DB_USER_PASS" || -z "$BASE_DOMAIN" ]]; then
        dialog --title "Input Error" --msgbox "One or more fields are empty. Please try again." 8 50
        return 1
    fi

    # Ensure log file exists and is writable
    touch "$MAIN_LOG_FILE"
    chmod 644 "$MAIN_LOG_FILE"

    # Set variables for setup
    NEXTCLOUD_ADMIN_PASSWORD="$ADMIN_PASS"
    MYSQL_ROOT_PASSWORD="$DB_ROOT_PASS"
    MYSQL_PASSWORD="$DB_USER_PASS"
    BASE_DOMAIN="$BASE_DOMAIN"
    SUBDOMAIN="${SUBDOMAIN:-nextcloud}"

    # Start logging
    {
        set -x
        echo "--- TUI: Setup started at $(date) ---"
    } >> "$MAIN_LOG_FILE" 2>&1

    # Run preflight checks
    echo "[*] Running pre-flight checks..." >> "$MAIN_LOG_FILE" 2>&1
    preflight_checks >> "$MAIN_LOG_FILE" 2>&1

    # Install dependencies
    echo "[1/10] Installing system dependencies..." >> "$MAIN_LOG_FILE" 2>&1
    install_dependencies >> "$MAIN_LOG_FILE" 2>&1

    # Gather config
    echo "[2/10] Gathering configuration from environment..." >> "$MAIN_LOG_FILE" 2>&1
    gather_config_from_env >> "$MAIN_LOG_FILE" 2>&1

    # Consolidated Cloudflare setup - interactive
    echo "[3/10] Setting up Cloudflare Tunnel..." >> "$MAIN_LOG_FILE" 2>&1
    if [ ! -f /root/.cloudflared/cert.pem ]; then
        dialog --msgbox "Cloudflare authentication required. The authentication process will start now." 8 60
        cloudflared tunnel login | dialog --programbox "Cloudflare Authentication - Open the URL in your browser and follow the instructions." 20 80
        if [ ! -f /root/.cloudflared/cert.pem ]; then
            echo "Certificate still not found after login. If running over SSH, the cert.pem was likely downloaded to your local machine." >> "$MAIN_LOG_FILE"
            echo "Please copy cert.pem to /root/.cloudflared/cert.pem on this device and rerun the script." >> "$MAIN_LOG_FILE"
            dialog --title "Error" --msgbox "Missing Cloudflare certificate. If over SSH, copy cert.pem manually to /root/.cloudflared/cert.pem and rerun." 10 70
            return 1
        fi
    fi

    local TUNNEL_NAME="nextcloud-tunnel-$SUBDOMAIN"
    CF_TUNNEL_ID=$(cloudflared tunnel list --output json 2>/dev/null | jq -r ".[] | select(.name==\"$TUNNEL_NAME\") | .id" || true)
    if [[ -n "$CF_TUNNEL_ID" && "$CF_TUNNEL_ID" != "null" ]]; then
        echo "Warning: Tunnel with name $TUNNEL_NAME already exists (ID: $CF_TUNNEL_ID)." >> "$MAIN_LOG_FILE"
        local choice
        choice=$(dialog --stdout --title "Existing Tunnel" --menu "Tunnel exists. Choose action:" 12 60 3 \
            d "Delete and recreate" \
            c "Choose different subdomain" \
            r "Reuse existing")
        if [ $? -ne 0 ]; then return 1; fi
        case "$choice" in
            d)
                echo "Deleting existing tunnel..." >> "$MAIN_LOG_FILE"
                cloudflared tunnel delete "$CF_TUNNEL_ID" >> "$MAIN_LOG_FILE" 2>&1 || {
                    dialog --title "Error" --msgbox "Failed to delete existing tunnel." 8 50
                    return 1
                }
                CF_TUNNEL_ID=""
                ;;
            c)
                SUBDOMAIN=$(dialog --stdout --inputbox "Enter a new subdomain:" 8 50)
                if [ $? -ne 0 ] || [ -z "$SUBDOMAIN" ]; then return 1; fi
                CF_HOSTNAME="$SUBDOMAIN.$BASE_DOMAIN"
                NEXTCLOUD_TRUSTED_DOMAINS="$CF_HOSTNAME"
                TUNNEL_NAME="nextcloud-tunnel-$SUBDOMAIN"
                CF_TUNNEL_ID=$(cloudflared tunnel list --output json 2>/dev/null | jq -r ".[] | select(.name==\"$TUNNEL_NAME\") | .id" || true)
                if [[ -n "$CF_TUNNEL_ID" && "$CF_TUNNEL_ID" != "null" ]]; then
                    dialog --title "Error" --msgbox "Tunnel with new name $TUNNEL_NAME also exists. Please choose another or delete manually." 8 60
                    return 1
                fi
                ;;
            r)
                # Reuse
                ;;
        esac
    fi
    if [[ -z "$CF_TUNNEL_ID" || "$CF_TUNNEL_ID" == "null" ]]; then
        echo "Creating new tunnel: $TUNNEL_NAME" >> "$MAIN_LOG_FILE"
        CF_TUNNEL_ID=$(cloudflared tunnel create "$TUNNEL_NAME" | awk '/Created tunnel/{print $NF}')
        if [ $? -ne 0 ] || [ -z "$CF_TUNNEL_ID" ]; then
            dialog --title "Error" --msgbox "Failed to create tunnel." 8 50
            return 1
        fi
    else
        echo "Reusing existing tunnel ID: $CF_TUNNEL_ID" >> "$MAIN_LOG_FILE"
    fi
    echo "Routing DNS for $CF_HOSTNAME..." >> "$MAIN_LOG_FILE"
    cloudflared tunnel route dns --overwrite-dns "$CF_TUNNEL_ID" "$CF_HOSTNAME" >> "$MAIN_LOG_FILE" 2>&1 || {
        dialog --title "Error" --msgbox "Failed to create or update DNS route for $CF_HOSTNAME." 8 60
        return 1
    }
    local CREDENTIALS_FILE="/root/.cloudflared/${CF_TUNNEL_ID}.json"
    if [[ ! -f "$CREDENTIALS_FILE" ]]; then
        echo "Credentials file missing. Generating by running tunnel temporarily..." >> "$MAIN_LOG_FILE"
        cloudflared tunnel --credentials-file "$CREDENTIALS_FILE" run "$TUNNEL_NAME" & 
        local temp_pid=$!
        sleep 5
        kill "$temp_pid" 2>/dev/null || true
        if [[ ! -f "$CREDENTIALS_FILE" ]]; then
            dialog --title "Error" --msgbox "Failed to generate credentials file." 8 50
            return 1
        fi
    fi
    mkdir -p /etc/cloudflared
    cat > /etc/cloudflared/config.yml <<EOF
tunnel: $TUNNEL_NAME
credentials-file: $CREDENTIALS_FILE
ingress:
  - hostname: $CF_HOSTNAME
    service: http://localhost:$NEXTCLOUD_PORT
  - service: http_status:404
EOF
    cat >/etc/systemd/system/cloudflared.service <<EOF
[Unit]
Description=Cloudflare Tunnel for Nextcloud
After=network-online.target
[Service]
Type=notify
ExecStart=/usr/bin/cloudflared --config /etc/cloudflared/config.yml tunnel run
Restart=on-failure
RestartSec=5s
[Install]
WantedBy=multi-user.target
EOF

    systemctl daemon-reload >> "$MAIN_LOG_FILE" 2>&1
    if systemctl is-enabled --quiet cloudflared 2>/dev/null; then
        echo "[*] Service already enabled, restarting..." >> "$MAIN_LOG_FILE"
        systemctl restart cloudflared >> "$MAIN_LOG_FILE" 2>&1
    else
        echo "[*] Enabling and starting service..." >> "$MAIN_LOG_FILE"
        systemctl enable --now cloudflared >> "$MAIN_LOG_FILE" 2>&1
    fi

    # Generate env file
    echo "[4/10] Generating .env configuration file..." >> "$MAIN_LOG_FILE" 2>&1
    generate_env_file >> "$MAIN_LOG_FILE" 2>&1

    # Deploy stack
    echo "[5/10] Deploying Docker stack..." >> "$MAIN_LOG_FILE" 2>&1
    deploy_docker_stack >> "$MAIN_LOG_FILE" 2>&1

    # Configure HTTPS
    echo "[6/10] Applying reverse proxy HTTPS configuration..." >> "$MAIN_LOG_FILE" 2>&1
    configure_nextcloud_https >> "$MAIN_LOG_FILE" 2>&1

    # Validate
    echo "[10/10] Validating setup..." >> "$MAIN_LOG_FILE" 2>&1
    validate_setup >> "$MAIN_LOG_FILE" 2>&1

    echo "✅ Installation complete!" >> "$MAIN_LOG_FILE" 2>&1

    dialog --title "Setup Log" --tailbox "$MAIN_LOG_FILE" 25 80 &
    local tail_pid=$!

    sleep 1
    kill "$tail_pid" 2>/dev/null || true
    reset_terminal

    dialog --title "Success" --msgbox "Setup completed successfully!" 8 40
}

# --- Run Backup ---
run_backup() {
    if ! is_stack_running; then
        dialog --title "Error" --msgbox "Nextcloud stack not running." 8 50
        return
    fi

    source "$ENV_FILE" 2>/dev/null || true
    dialog --title "Confirm" --yesno "Run backup now? Ensure backup drive is mounted." 8 60
    if [ $? -ne 0 ]; then return; fi

    (
        backup
    ) >> "$BACKUP_LOG_FILE" 2>&1 &
    local pid=$!

    dialog --title "Backup Log" --tailbox "$BACKUP_LOG_FILE" 25 80 &
    local tail_pid=$!

    wait_for_completion "$pid" "Backup in Progress" "Running backup..."
    local exit_code=$?

    kill "$tail_pid" 2>/dev/null || true
    reset_terminal

    if [ $exit_code -eq 0 ]; then
        dialog --title "Success" --msgbox "Backup completed successfully!" 8 40
    else
        dialog --title "Error" --msgbox "Backup failed. Check log at $BACKUP_LOG_FILE." 8 60
    fi
}

# --- Run Restore ---
run_restore() {
    if ! is_stack_running; then
        dialog --title "Error" --msgbox "Nextcloud stack not running." 8 50
        return
    fi

    source "$ENV_FILE" 2>/dev/null || true
    if ! mountpoint -q "$BACKUP_MOUNTDIR"; then
        dialog --title "Error" --msgbox "Backup drive not mounted. Configure in settings first." 8 60
        return
    fi

    local backups
    mapfile -t backups < <(find "$BACKUP_MOUNTDIR" -maxdepth 1 -name 'nextcloud_backup_*.tar.gz' -print0 | xargs -0 ls -t)
    if [ ${#backups[@]} -eq 0 ]; then
        dialog --title "Error" --msgbox "No backups found in $BACKUP_MOUNTDIR." 8 60
        return
    fi

    local options=()
    for i in "${!backups[@]}"; do
        options+=("$((i+1))" "$(basename "${backups[$i]}")")
    done

    local choice
    choice=$(dialog --stdout --title "Select Backup" --menu "Choose a backup to restore:" $HEIGHT $WIDTH $CHOICE_HEIGHT "${options[@]}")
    if [ $? -ne 0 ]; then return; fi

    local selected="${backups[$((choice-1))]}"

    dialog --title "WARNING" --yesno "This will OVERWRITE your current data, config, and database with the contents from $selected.\n\nThis operation is irreversible. Proceed?" 10 70
    if [ $? -ne 0 ]; then return; fi

    (
        restore "$selected" --no-prompt
    ) >> "$RESTORE_LOG_FILE" 2>&1 &
    local pid=$!

    dialog --title "Restore Log" --tailbox "$RESTORE_LOG_FILE" 25 80 &
    local tail_pid=$!

    wait_for_completion "$pid" "Restore in Progress" "Running restore..."
    local exit_code=$?

    kill "$tail_pid" 2>/dev/null || true
    reset_terminal

    if [ $exit_code -eq 0 ]; then
        dialog --title "Success" --msgbox "Restore completed successfully!" 8 40
    else
        dialog --title "Error" --msgbox "Restore failed. Check log at $RESTORE_LOG_FILE." 8 60
    fi
}

# --- Setup FTP Server ---
setup_ftp_server() {
    if [[ $EUID -ne 0 ]]; then
        dialog --title "Error" --msgbox "This option must be run as root." 8 50
        return
    fi

    source "$ENV_FILE" 2>/dev/null || { dialog --title "Error" --msgbox "Environment file not found." 8 50; return; }

    local nc_cid=$(get_nc_cid)
    if [[ -z "$nc_cid" ]]; then
        dialog --title "Error" --msgbox "Nextcloud container not running." 8 50
        return
    fi

    local nc_user
    nc_user=$(dialog --stdout --title "Nextcloud User" --inputbox "Enter the Nextcloud username for FTP access:" 8 50)
    if [ $? -ne 0 ] || [ -z "$nc_user" ]; then return; fi

    # Verify user exists
    if ! docker exec -u www-data "$nc_cid" php occ user:info "$nc_user" >/dev/null 2>&1; then
        dialog --title "Error" --msgbox "Nextcloud user '$nc_user' does not exist." 8 50
        return
    fi

    local ftp_user
    ftp_user=$(dialog --stdout --title "FTP Username" --inputbox "Enter FTP username (default: camera):" 8 50 "camera")
    if [ $? -ne 0 ]; then return; fi
    ftp_user="${ftp_user:-camera}"

    local ftp_pass
    ftp_pass=$(dialog --stdout --title "FTP Password" --passwordbox "Enter FTP password:" 8 50)
    if [ $? -ne 0 ] || [ -z "$ftp_pass" ]; then return; fi

    local confirm_pass
    confirm_pass=$(dialog --stdout --title "Confirm Password" --passwordbox "Confirm FTP password:" 8 50)
    if [ $? -ne 0 ] || [ "$ftp_pass" != "$confirm_pass" ]; then
        dialog --title "Error" --msgbox "Passwords do not match." 8 50
        return
    fi

    dialog --title "Confirm" --yesno "Setup FTP server for user '$nc_user' with FTP user '$ftp_user'? This will install vsftpd and configure it." 10 60
    if [ $? -ne 0 ]; then return; fi

    # Install packages
    apt-get update -y
    apt-get install -y vsftpd libpam-pwdfile apache2-utils inotify-tools

    # Only backup the original conf file if a backup doesn't already exist
    if [ ! -f /etc/vsftpd.conf.bak ]; then
        cp /etc/vsftpd.conf /etc/vsftpd.conf.bak
    fi

    # Set www-data home directory to NEXTCLOUD_DATA_DIR to avoid fallback issues
    if [ "$(getent passwd www-data | cut -d: -f6)" != "$NEXTCLOUD_DATA_DIR" ]; then
        usermod -d "$NEXTCLOUD_DATA_DIR" www-data
    fi

    # Configure vsftpd.conf
    cat > /etc/vsftpd.conf <<EOF
listen=YES
listen_ipv6=NO
local_enable=YES
write_enable=YES
local_umask=022
chroot_local_user=YES
allow_writeable_chroot=YES
guest_enable=YES
guest_username=www-data
virtual_use_local_privs=YES
user_sub_token=\$USER
local_root=${NEXTCLOUD_DATA_DIR}/\$USER/files/uploads
user_config_dir=/etc/vsftpd/user_conf
pam_service_name=vsftpd.virtual
EOF

    # PAM config
    cat > /etc/pam.d/vsftpd.virtual <<EOF
auth    required pam_pwdfile.so pwdfile /etc/vsftpd/ftppasswd
account required pam_permit.so
EOF

    # Create uploads dir
    local upload_dir="${NEXTCLOUD_DATA_DIR}/${nc_user}/files/uploads"
    mkdir -p "$upload_dir"
    chown -R www-data:www-data "${NEXTCLOUD_DATA_DIR}/${nc_user}"

    # Ensure config directory exists before writing to it
    mkdir -p /etc/vsftpd/user_conf

    # Add virtual user (create password file or append to existing)
    if [ ! -f /etc/vsftpd/ftppasswd ]; then
        htpasswd -b -c -d /etc/vsftpd/ftppasswd "$ftp_user" "$ftp_pass"
    else
        htpasswd -b -d /etc/vsftpd/ftppasswd "$ftp_user" "$ftp_pass"
    fi

    # User config for chroot
    echo "local_root=${NEXTCLOUD_DATA_DIR}/${nc_user}/files/uploads" > /etc/vsftpd/user_conf/"$ftp_user"

    # Restart vsftpd
    systemctl restart vsftpd

    # Setup inotify watcher script
    cat > /usr/local/bin/nextcloud-ftp-sync.sh <<EOF
#!/bin/bash

NC_USER="\$1"
WATCH_DIR="${NEXTCLOUD_DATA_DIR}/\$NC_USER/files/uploads"
REPO_DIR="/opt/raspi-nextcloud-setup"
COMPOSE_FILE="\$REPO_DIR/docker-compose.yml"
NC_CID=\$(docker compose -f "\$COMPOSE_FILE" ps -q nextcloud 2>/dev/null || true)
if [[ -z "\$NC_CID" ]]; then exit 1; fi

while true; do
  inotifywait -e create,modify,move,delete -r "\$WATCH_DIR" && \
  docker exec -u www-data "\$NC_CID" php occ files:scan "\$NC_USER"
done
EOF
    chmod +x /usr/local/bin/nextcloud-ftp-sync.sh

    # Systemd service
    cat > /etc/systemd/system/nextcloud-ftp-sync@.service <<EOF
[Unit]
Description=Nextcloud FTP Sync Watcher for %i

[Service]
ExecStart=/usr/local/bin/nextcloud-ftp-sync.sh %i
Restart=always

[Install]
WantedBy=multi-user.target
EOF

    systemctl daemon-reload
    systemctl enable --now nextcloud-ftp-sync@"$nc_user"

    dialog --title "Success" --msgbox "FTP server setup complete. Connect with user '$ftp_user' and password provided. Uploads to '$upload_dir' will trigger Nextcloud scan." 10 70
}

# --- Setup Home Assistant ---
setup_home_assistant() {
    source "$ENV_FILE" 2>/dev/null || { dialog --title "Error" --msgbox "Environment file not found. Run Nextcloud setup first." 8 50; return; }

    if grep -q "homeassistant:" "$COMPOSE_FILE"; then
        dialog --title "Warning" --yesno "Home Assistant is already configured in docker-compose.yml. Reconfigure?" 8 50
        if [ $? -ne 0 ]; then return; fi
    fi

    local ha_subdomain
    ha_subdomain=$(dialog --stdout --title "Home Assistant Subdomain" --inputbox "Enter subdomain for Home Assistant (e.g., ha):" 8 50 "ha")
    if [ $? -ne 0 ] || [ -z "$ha_subdomain" ]; then return; fi

    local base_domain="${BASE_DOMAIN:-example.com}"
    local ha_hostname="$ha_subdomain.$base_domain"
    local ha_trusted_domains="$ha_hostname"
    local ha_port="${HA_PORT:-8123}"

    local zigbee_device
    zigbee_device=$(dialog --stdout --title "Zigbee Dongle" --inputbox "Enter Zigbee dongle device path (e.g., /dev/ttyACM0; leave blank if none): Run 'ls /dev/tty*' to find it." 10 60)
    if [ $? -ne 0 ]; then return; fi

    dialog --title "Confirm" --yesno "Setup Home Assistant on port $ha_port with hostname $ha_hostname? Zigbee: ${zigbee_device:-None}. This will update docker-compose.yml and the Cloudflare Tunnel." 10 70
    if [ $? -ne 0 ]; then return; fi

    # Update .env
    update_env "HA_PORT" "$ha_port"
    update_env "HA_TRUSTED_DOMAINS" "$ha_trusted_domains"

    # Add HA to docker-compose.yml (idempotent: remove existing HA block first)
    sed -i '/homeassistant:/,/^$/d' "$COMPOSE_FILE"  # Remove existing HA block
    cat >> "$COMPOSE_FILE" << EOF

  homeassistant:
    image: homeassistant/home-assistant:stable
    restart: unless-stopped
    ports:
      - "${HA_PORT}:8123"
    volumes:
      - ha_config:/config
    environment:
      - TZ=Etc/UTC  # Adjust timezone as needed
    logging:
      driver: "json-file"
      options:
        max-size: "10m"
        max-file: "3"
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:8123"]
      interval: 30s
      timeout: 10s
      retries: 5
EOF

    if [[ -n "$zigbee_device" ]]; then
        echo "    devices:" >> "$COMPOSE_FILE"
        echo "      - $zigbee_device:$zigbee_device" >> "$COMPOSE_FILE"
    fi

    cat >> "$COMPOSE_FILE" << EOF

volumes:
  ha_config:
EOF

    # Update Cloudflare Tunnel config (add ingress rule idempotently)
    local tunnel_config="/etc/cloudflared/config.yml"
    if grep -q "hostname: $ha_hostname" "$tunnel_config"; then
        sed -i "/hostname: $ha_hostname/,/service:/d" "$tunnel_config"
    fi
    sed -i '/- service: http_status:404/i \  - hostname: '"$ha_hostname"'\n    service: http://localhost:'"$ha_port" "$tunnel_config"

    # Route DNS for HA
    cloudflared tunnel route dns --overwrite-dns "$CF_TUNNEL_ID" "$ha_hostname" || {
        dialog --title "Error" --msgbox "Failed to route DNS for $ha_hostname." 8 50
        return 1
    }

    # Deploy and restart
    docker compose -f "$COMPOSE_FILE" up -d --remove-orphans
    systemctl restart cloudflared

    dialog --title "Success" --msgbox "Home Assistant setup complete. Access at https://$ha_hostname. Initial setup may take a few minutes. If using Zigbee, configure in HA integrations." 10 70
}

# --- Main Menu ---
main_menu() {
    while true; do
        if $is_sd_boot; then
            local choice
            choice=$(dialog --backtitle "Nextcloud Pi Manager (SD Boot)" \
                --stdout \
                --title "Main Menu" \
                --cancel-label "Exit" \
                --menu "Select an option:" \
                $HEIGHT $WIDTH $CHOICE_HEIGHT \
                1 "Flash OS to Drive (NVMe/USB SSD)" \
                2 "Expand Filesystem with LVM")
            local retval=$?
            if [ $retval -ne 0 ]; then
                clear
                echo "Exiting."
                exit 0
            fi

            case "$choice" in
                1) flash_to_nvme ;;
                2) lvm_storage_extension ;;
            esac
        else
            local choice
            choice=$(dialog --stdout \
                --backtitle "Raspi Nextcloud TUI" \
                --title "Main Menu" \
                --menu "Select an option:" $HEIGHT $WIDTH $CHOICE_HEIGHT \
                1 "Initial Nextcloud+Cloudflare Setup" \
                2 "Run Backup" \
                3 "Run Restore" \
                4 "Configure Backup Settings" \
                5 "System Health Check" \
                6 "Maintenance Menu" \
                7 "View Logs" \
                8 "Setup FTP Server" \
                9 "Setup Home Assistant" \
                0 "Exit")
            local retval=$?
            if [ $retval -ne 0 ] || [ "$choice" = "0" ]; then
                clear
                exit 0
            fi

            case "$choice" in
                1) run_initial_setup ;;
                2) run_backup ;;
                3) run_restore ;;
                4) configure_backup_settings ;;
                5) 
                    system_health_check
                    dialog --title "System Health Check" --textbox "$HEALTH_LOG_FILE" 25 80
                    ;;
                6) maintenance_menu ;;
                7) logs_menu ;;
                8) setup_ftp_server ;;
                9) setup_home_assistant ;;
            esac
        fi
        reset_terminal  # Ensure clean state after actions
    done
}

# --- Script Entrypoint ---
cd "$REPO_DIR" || { echo "Error: Cannot access $REPO_DIR"; exit 1; }
main_menu