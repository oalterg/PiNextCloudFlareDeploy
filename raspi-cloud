#!/bin/bash
# raspi-cloud — A TUI for managing the Nextcloud environment (now central script with integrated setup, backup, and restore)

set -euo pipefail

# --- Configuration and Initialization ---
REPO_DIR="/opt/raspi-nextcloud-setup"
LOG_DIR="/var/log/raspi-nextcloud"
MAIN_LOG_FILE="$LOG_DIR/main_setup.log"
BACKUP_LOG_FILE="$LOG_DIR/backup.log"
RESTORE_LOG_FILE="$LOG_DIR/restore.log"
LVM_LOG_FILE="$LOG_DIR/lvm_migration.log"
FLASH_LOG_FILE="$LOG_DIR/flash_to_drive.log"
ENV_FILE="$REPO_DIR/.env"
ENV_TEMPLATE="$REPO_DIR/.env.template"
COMPOSE_FILE="$REPO_DIR/docker-compose.yml"
CRON_FILE="/etc/cron.d/nextcloud-backup"
NEXTCLOUD_CRON_FILE="/etc/cron.d/nextcloud-cron"
HEALTH_LOG_FILE="$LOG_DIR/health_check.log"
HEIGHT=20
WIDTH=70
CHOICE_HEIGHT=8
BOOT_PARTITION="/boot/firmware"  # Standard for Pi 5 Bookworm
BACKUP_MOUNTDIR="/mnt/backup"  # Hardcoded mount point

# Detect boot device
root_dev=$(findmnt -o SOURCE / | tail -1 | cut -d'[' -f1)
# Robustly get the parent disk name (e.g., nvme0n1 from /dev/nvme0n1p2 or sda from /dev/sda2)
root_disk_name=$(lsblk -no PKNAME "$root_dev" 2>/dev/null || basename "$root_dev" | sed 's/p[0-9]*$//')

if [[ $root_dev == /dev/mmcblk* ]]; then
    is_sd_boot=true
else
    is_sd_boot=false
fi

mkdir -p "$LOG_DIR"

# --- Helper Functions (moved up for availability) ---
update_env() {
    local key="$1" value="$2"
    if grep -q "^$key=" "$ENV_FILE" 2>/dev/null; then
        sed -i "s|^$key=.*|$key=$value|" "$ENV_FILE"
    else
        echo "$key=$value" >> "$ENV_FILE"
    fi
}

die() { echo "[ERROR] $1" >&2; exit 1; }


# --- Generate .env.template and docker-compose.yml if not present ---
generate_env_template() {
    if [[ ! -f "$REPO_DIR/.env.template" ]]; then
        cat > "$REPO_DIR/.env.template" << 'EOF'
# .env.template
NEXTCLOUD_ADMIN_USER=admin
NEXTCLOUD_ADMIN_PASSWORD=changeme
NEXTCLOUD_TRUSTED_DOMAINS=cloud.yourdomain.com
NEXTCLOUD_PORT=8080
MYSQL_ROOT_PASSWORD=changeme_root
MYSQL_DATABASE=nextcloud
MYSQL_USER=nextcloud_user
MYSQL_PASSWORD=changeme
NEXTCLOUD_DATA_DIR=/home/user/nextcloud
BACKUP_RETENTION=8
BACKUP_MINUTE=0
BACKUP_HOUR=3
BACKUP_DAY_MONTH=*
BACKUP_MONTH=*
BACKUP_DAY_WEEK=0
CF_TUNNEL_ID=
TRUSTED_PROXIES_0=172.18.0.1
TRUSTED_PROXIES_1=127.0.0.1
HA_PORT=8123
HA_TRUSTED_DOMAINS=
# Cloudflare Tokens (Set via GUI or manual)
CF_TOKEN_NC=
CF_TOKEN_HA=
EOF
    fi
}

generate_docker_compose() {
    if [[ ! -f "$COMPOSE_FILE" ]]; then
        cat > "$COMPOSE_FILE" << 'EOF'
services:
  nextcloud:
    image: nextcloud:31-apache
    restart: unless-stopped
    ports:
      - "${NEXTCLOUD_PORT}:80"
    volumes:
      - nextcloud_html:/var/www/html
      - ${NEXTCLOUD_DATA_DIR}:/var/www/html/data
    environment:
      - NEXTCLOUD_ADMIN_USER=${NEXTCLOUD_ADMIN_USER}
      - NEXTCLOUD_ADMIN_PASSWORD=${NEXTCLOUD_ADMIN_PASSWORD}
      - NEXTCLOUD_TRUSTED_DOMAINS=${NEXTCLOUD_TRUSTED_DOMAINS}
      - MYSQL_PASSWORD=${MYSQL_PASSWORD}
      - MYSQL_DATABASE=${MYSQL_DATABASE}
      - MYSQL_USER=${MYSQL_USER}
      - MYSQL_HOST=db
    depends_on:
      db:
        condition: service_healthy
    logging:
      driver: "json-file"
      options:
        max-size: "10m"
        max-file: "3"
    healthcheck:
      test: ["CMD-SHELL", "curl -f http://localhost/status.php || exit 1"]
      interval: 30s
      timeout: 10s
      retries: 5

  db:
    image: mariadb:11.2
    restart: unless-stopped
    command: --transaction-isolation=READ-COMMITTED --binlog-format=ROW
    volumes:
      - db_data:/var/lib/mysql
    environment:
      - MYSQL_ROOT_PASSWORD=${MYSQL_ROOT_PASSWORD}
      - MYSQL_PASSWORD=${MYSQL_PASSWORD}
      - MYSQL_DATABASE=${MYSQL_DATABASE}
      - MYSQL_USER=${MYSQL_USER}
    logging:
      driver: "json-file"
      options:
        max-size: "10m"
        max-file: "3"
    healthcheck:
      test: ["CMD", "healthcheck.sh", "--su-mysql", "--connect", "--innodb_initialized"]
      interval: 15s
      timeout: 5s
      retries: 5

volumes:
  nextcloud_html:
  db_data:
EOF
    fi
}

# Generate files on startup
generate_env_template
generate_docker_compose

# --- Helper Functions ---
die_tui() {
    dialog --title "Error" --msgbox "$1" 8 60
    exit 1
}

get_nc_cid() {
    docker compose -f "$COMPOSE_FILE" ps -q nextcloud 2>/dev/null || true
}

is_stack_running() {
    [[ -n "$(get_nc_cid)" ]]
}

wait_for_completion() {
    local pid=$1
    local title=$2
    local text=$3
    while kill -0 "$pid" 2>/dev/null; do
        sleep 1
    done
    wait "$pid"
    return $?
}

reset_terminal() {
    sleep 0.5
    stty sane 2>/dev/null || true
}

wait_for_healthy() {
    local service_name="$1"
    local timeout_seconds="$2"
    local container_id
    echo "Waiting for $service_name to become healthy..."
    
    # Retry loop to find container ID (crucial during startup when containers are just created)
    local retries=10
    while [[ $retries -gt 0 ]]; do
        container_id=$(docker compose -f "$COMPOSE_FILE" ps -q "$service_name" 2>/dev/null)
        if [[ -n "$container_id" ]]; then break; fi
        sleep 2
        ((retries--))
    done

    [[ -z "$container_id" ]] && { echo "Could not find container for service '$service_name'."; return 1; }
    
    local end_time=$((SECONDS + timeout_seconds))
    while [ $SECONDS -lt $end_time ]; do
        local status
        status=$(docker inspect --format="{{if .State.Health}}{{.State.Health.Status}}{{end}}" "$container_id" 2>/dev/null || echo "inspecting")
        [ "$status" == "healthy" ] && { echo "✅ $service_name is healthy."; return 0; }
        sleep 5
    done
    echo "❌ $service_name did not become healthy." >&2
    return 1
}

# --- Tunnel Management (Cloudflare & Pangolin) ---

# Helps configure Trusted Proxies for Docker subnet to allow Cloudflare Tunnel traffic
configure_docker_subnet_trust() {
    echo "[INFO] Configuring trusted proxies for Docker Subnet..."
    local nc_cid=$(get_nc_cid)
    local ha_cid=$(docker compose -f "$COMPOSE_FILE" ps -q homeassistant 2>/dev/null || true)
    
    # Get Docker Bridge Subnet
    local subnet
    # Try to find the network used by nextcloud
    if [[ -n "$nc_cid" ]]; then
        local net_name=$(docker inspect "$nc_cid" --format='{{range $k, $v := .NetworkSettings.Networks}}{{$k}}{{end}}')
        if [[ -n "$net_name" ]]; then
            subnet=$(docker network inspect "$net_name" --format='{{(index .IPAM.Config 0).Subnet}}' 2>/dev/null || true)
        fi
    fi
    
    # Fallback default if detection fails
    if [[ -z "$subnet" ]]; then
        subnet="172.16.0.0/12"
    fi
    echo "[INFO] Detected Docker Subnet: $subnet"

    # 1. Update Nextcloud Trusted Proxies
    if [[ -n "$nc_cid" ]]; then
        # Use index 10 to avoid conflict with existing static ones
        docker exec -u www-data "$nc_cid" php occ config:system:set trusted_proxies 10 --value="$subnet" || true
        # Also ensure localhost is trusted
        docker exec -u www-data "$nc_cid" php occ config:system:set trusted_proxies 11 --value="127.0.0.1" || true
    fi

    # 2. Update Home Assistant Trusted Proxies
    if [[ -n "$ha_cid" ]]; then
        configure_ha_proxy_settings "$subnet" "$ha_cid"
    fi
}

update_tunnel_services() {
    echo "[INFO] Updating tunnel services in docker-compose.yml..."
    source "$ENV_FILE"

    # 1. Strip existing service definitions (Newt and Cloudflared)
    # We use awk to filter out specific blocks. This assumes standard indentation.
    # It removes lines starting with '  newt:', '  cloudflared-nc:', '  cloudflared-ha:' and their indented children.
    
    cp "$COMPOSE_FILE" "${COMPOSE_FILE}.bak"
    
    awk '
    BEGIN { skip=0; indent=0 }
    /^  (newt|cloudflared-nc|cloudflared-ha):/ { skip=1; indent=length($0)-length($2); next }
    skip && /^ +/ { next } # Skip indented lines if skipping
    skip && !/^ +/ { skip=0 } # Stop skipping if indent is gone
    { print }
    ' "${COMPOSE_FILE}.bak" > "$COMPOSE_FILE"

    # 2. Prepare New Blocks
    local new_blocks=""
    
    # Logic: If ANY Cloudflare token is present, we disable Pangolin (Newt)
    if [[ -n "${CF_TOKEN_NC:-}" ]] || [[ -n "${CF_TOKEN_HA:-}" ]]; then
        echo "[INFO] Cloudflare Mode Active."
        
        if [[ -n "${CF_TOKEN_NC:-}" ]]; then
            echo "[INFO] Adding Cloudflare Tunnel for Nextcloud..."
            new_blocks="${new_blocks}
  cloudflared-nc:
    image: cloudflare/cloudflared:latest
    restart: unless-stopped
    command: tunnel run
    environment:
      - TUNNEL_TOKEN=\${CF_TOKEN_NC}
    depends_on:
      - nextcloud
"
        fi
        
        if [[ -n "${CF_TOKEN_HA:-}" ]]; then
            echo "[INFO] Adding Cloudflare Tunnel for Home Assistant..."
             new_blocks="${new_blocks}
  cloudflared-ha:
    image: cloudflare/cloudflared:latest
    restart: unless-stopped
    command: tunnel run
    environment:
      - TUNNEL_TOKEN=\${CF_TOKEN_HA}
"
             # Depends on HA if HA is in the file? 
             if grep -q "homeassistant:" "$COMPOSE_FILE"; then
                  new_blocks="${new_blocks}    depends_on:
      - homeassistant
"
             fi
        fi
        
    elif [[ -n "${PANGOLIN_ENDPOINT:-}" ]]; then
        echo "[INFO] Pangolin Mode Active."
        new_blocks="${new_blocks}
  newt:
    image: fosrl/newt:latest
    restart: unless-stopped
    volumes:
      - /var/run/docker.sock:/var/run/docker.sock:ro
    environment:
      - PANGOLIN_ENDPOINT=\${PANGOLIN_ENDPOINT}
      - NEWT_ID=\${NEWT_ID}
      - NEWT_SECRET=\${NEWT_SECRET}
"
    else
        echo "[WARN] No tunnel configuration found (Pangolin or Cloudflare)."
    fi

    # 3. Inject New Blocks
    # Insert before 'volumes:' line
    if [[ -n "$new_blocks" ]]; then
        # Use a temp file for safety
        awk -v block="$new_blocks" '/^volumes:/ { print block } { print }' "$COMPOSE_FILE" > "${COMPOSE_FILE}.tmp" && mv "${COMPOSE_FILE}.tmp" "$COMPOSE_FILE"
    fi
    
    # 4. Apply Changes
    echo "[INFO] Redeploying stack..."
    docker compose --env-file "$ENV_FILE" -f "$COMPOSE_FILE" up -d --remove-orphans
    
    # 5. Configure Trust
    # Wait briefly for containers to spin up so network inspection works
    sleep 5
    #configure_docker_subnet_trust
    configure_nextcloud_https

    # Restart NC/HA to apply proxy trust changes if needed
    echo "[INFO] Reloading services to apply proxy settings..."
    docker compose -f "$COMPOSE_FILE" restart nextcloud homeassistant 2>/dev/null || true
    
    echo "[INFO] Tunnel configuration complete."
}

# --- Maintenance Mode Helpers ---
# Sets maintenance mode.
# $1: Mode ("--on" or "--off")
# $2: (Optional) Log file to redirect output to
set_maintenance_mode() {
    local mode="$1"
    local log_file="${2:-/dev/null}" # Default to /dev/null if no log file

    if ! is_stack_running; then
        echo "[WARN] Stack not running, cannot set maintenance mode." >> "$log_file"
        return 1
    fi

    local nc_cid
    nc_cid=$(get_nc_cid)
    if [[ -z "$nc_cid" ]]; then
        echo "[WARN] Nextcloud container not found, cannot set maintenance mode." >> "$log_file"
        return 1
    fi

    # Check if container is actually running
    if ! docker inspect --format '{{.State.Running}}' "$nc_cid" 2>/dev/null | grep -q '^true$'; then
         echo "[WARN] Nextcloud container not running, cannot set maintenance mode." >> "$log_file"
         return 1
    fi

    if docker exec -u www-data "$nc_cid" php occ maintenance:mode "$mode" >> "$log_file" 2>&1; then
        echo "[INFO] Maintenance mode set to $mode." >> "$log_file"
        return 0
    else
        echo "[WARN] Failed to set maintenance mode to $mode." >> "$log_file"
        return 1 # Return error
    fi
}

# Gets maintenance mode status
# ECHOES 0 if enabled, 1 if disabled, 2 if error
# Always exits with 0 to prevent script abort (due to set -e)
get_maintenance_status() {
    if ! is_stack_running; then echo 2; return 0; fi # return 0 is for set -e
    local nc_cid
    nc_cid=$(get_nc_cid)
    if [[ -z "$nc_cid" ]]; then echo 2; return 0; fi

    local current_status
    # Capture the output, exit code since it is 0 in both states
    current_status=$(docker exec -u www-data "$nc_cid" php occ maintenance:mode 2>&1)
    if [ $? -ne 0 ]; then
         return 2 # Error querying
    fi
    # Check the text output to determine status
    if echo "$current_status" | grep -q "enabled"; then
        echo 0 # Enabled
    elif echo "$current_status" | grep -q "disabled"; then
        echo 1 # Disabled
    else
        echo 2 # Error
    fi
    
    # Crucially, always exit with success (0)
    return 0
 }

select_backup_drive() {  
    local drives
    mapfile -t drives < <(lsblk -o NAME,TYPE,RM,SIZE,MODEL | awk -v root="$root_disk_name" '$2=="disk" && $1 != root {print "/dev/" $1 " (" $4 ", " $5 ")"}')
    if [ ${#drives[@]} -eq 0 ]; then
        dialog --title "No Drives" --msgbox "No external drives detected. Insert one and try again." 8 50
        return 1
    fi
    local options=()
    for i in "${!drives[@]}"; do
        options+=("$((i+1))" "${drives[$i]}")
    done

    local choice
    choice=$(dialog --stdout --title "Select Backup Drive" --menu "Choose a drive:" $HEIGHT $WIDTH $CHOICE_HEIGHT "${options[@]}")
    if [ $? -ne 0 ]; then return 1; fi

    local selected_dev="/dev/$(echo "${drives[$((choice-1))]}" | awk '{print $1}' | sed 's/\/dev\///')"

    local fs_type
    fs_type=$(blkid -o value -s TYPE "$selected_dev")

    local format_choice=1
    if [[ -n "$fs_type" ]]; then
        dialog --title "Drive Formatted" --yesno "Drive is formatted as $fs_type. Format anyway? (erases all data)" 8 60
        format_choice=$?
    else
        dialog --title "Unformatted Drive" --yesno "Drive is unformatted. Format now? (required to use)" 8 60
        format_choice=$?
    fi

    if [ $format_choice -eq 0 ]; then
        dialog --title "Confirm Format" --yesno "Formatting will ERASE ALL DATA on $selected_dev. Proceed?" 8 60
        if [ $? -ne 0 ]; then return 1; fi
        mkfs.ext4 -F -L "NextcloudBackup" "$selected_dev" >> "$BACKUP_LOG_FILE" 2>&1
        if [ $? -ne 0 ]; then
            dialog --title "Error" --msgbox "Failed to format drive." 8 50
            return 1
        fi
        fs_type="ext4"
    elif [[ -z "$fs_type" ]]; then
        dialog --title "Error" --msgbox "Drive must be formatted to use." 8 50
        return 1
    fi

    local uuid
    uuid=$(blkid -o value -s UUID "$selected_dev")
    if [[ -z "$uuid" ]]; then
        dialog --title "Error" --msgbox "Failed to get UUID." 8 50
        return 1
    fi

    mkdir -p "$BACKUP_MOUNTDIR"

    sed -i "\|$BACKUP_MOUNTDIR|d" /etc/fstab
    echo "UUID=$uuid $BACKUP_MOUNTDIR $fs_type defaults,nofail,x-systemd.device-timeout=10 0 2" >> /etc/fstab

    mount -a >> "$BACKUP_LOG_FILE" 2>&1
    if ! mountpoint -q "$BACKUP_MOUNTDIR"; then
        dialog --title "Error" --msgbox "Failed to mount drive." 8 50
        return 1
    fi

    dialog --title "Success" --msgbox "Backup drive configured and mounted at $BACKUP_MOUNTDIR." 8 50
    return 0
}

# --- Installation Helper Functions ---
preflight_checks() {
    echo "[*] Running pre-flight checks..."
    [[ $EUID -ne 0 ]] && { dialog --title "Error" --msgbox "This script must be run as root." 8 60; exit 1; }
    
    if [[ -z "${SUDO_USER-}" && -z "${HEADLESS_MODE-}" ]]; then
        # In headless mode we might run as root directly via systemd
        echo "Could not determine SUDO_USER, assuming root context is intentional for headless/setup."
    fi
}

install_dependencies() {
    echo "[1/10] Installing system dependencies..."
    apt-get install -y ca-certificates curl gnupg lsb-release cron jq moreutils parted gpg git rsync lvm2 initramfs-tools
    
    # Docker setup (idempotent)
    if ! [ -f /etc/apt/keyrings/docker.gpg ]; then
        mkdir -p /etc/apt/keyrings
        curl -fsSL https://download.docker.com/linux/debian/gpg | gpg --dearmor -o /etc/apt/keyrings/docker.gpg
        echo "deb [arch=$(dpkg --print-architecture) signed-by=/etc/apt/keyrings/docker.gpg] https://download.docker.com/linux/debian $(lsb_release -cs) stable" > /etc/apt/sources.list.d/docker.list
        apt-get update -y
    fi
    apt-get install -y docker-ce docker-ce-cli containerd.io docker-compose-plugin
    
    systemctl enable --now docker
}

gather_config_from_env() {
    echo "[2/10] Gathering configuration from environment..."
    # Only enforce variables that MUST be present. In headless, these come from .env
    : "${NEXTCLOUD_ADMIN_PASSWORD:?}" "${MYSQL_ROOT_PASSWORD:?}" "${MYSQL_PASSWORD:?}"
    NEXTCLOUD_ADMIN_USER="admin"
    MYSQL_USER="nextcloud_user"
    MYSQL_DATABASE="nextcloud"
    # HEADLESS_MODE handling for HOME dir
    if [[ -n "${HEADLESS_MODE-}" ]]; then
         # In headless, use /home/admin or explicit var
         NEXTCLOUD_DATA_DIR="${NEXTCLOUD_DATA_DIR:-/home/admin/nextcloud}"
    else
         USER_HOME=$(eval echo "~$SUDO_USER")
         NEXTCLOUD_DATA_DIR="$USER_HOME/nextcloud"
    fi
    NEXTCLOUD_PORT="8080"
    BACKUP_RETENTION=8
    TRUSTED_PROXIES_0="${TRUSTED_PROXIES_0:-172.18.0.1}"
    TRUSTED_PROXIES_1="${TRUSTED_PROXIES_1:-127.0.0.1}"
}

generate_env_file() {
    echo "[4/10] Generating .env configuration file..."
    [[ -f "$ENV_TEMPLATE" ]] || die "Missing .env.template file."
    
    if [[ ! -f "$ENV_FILE" ]]; then cp "$ENV_TEMPLATE" "$ENV_FILE"; fi
    
    update_env "NEXTCLOUD_ADMIN_USER" "$NEXTCLOUD_ADMIN_USER"
    update_env "NEXTCLOUD_ADMIN_PASSWORD" "$NEXTCLOUD_ADMIN_PASSWORD"
    update_env "NEXTCLOUD_TRUSTED_DOMAINS" "${NEXTCLOUD_TRUSTED_DOMAINS:-}"
    update_env "NEXTCLOUD_PORT" "$NEXTCLOUD_PORT"
    update_env "MYSQL_ROOT_PASSWORD" "$MYSQL_ROOT_PASSWORD"
    update_env "MYSQL_DATABASE" "$MYSQL_DATABASE"
    update_env "MYSQL_USER" "$MYSQL_USER"
    update_env "MYSQL_PASSWORD" "$MYSQL_PASSWORD"
    update_env "NEXTCLOUD_DATA_DIR" "$NEXTCLOUD_DATA_DIR"
    update_env "BACKUP_RETENTION" "$BACKUP_RETENTION"
    update_env "TRUSTED_PROXIES_0" "$TRUSTED_PROXIES_0"
    update_env "TRUSTED_PROXIES_1" "$TRUSTED_PROXIES_1"
    
    chmod 600 "$ENV_FILE"
}
 
deploy_docker_stack() {
    echo "[5/10] Deploying Docker stack..."
    
    # Ensure docker is running (if just installed)
    if ! systemctl is-active --quiet docker; then
        echo "Waiting for Docker service..."
        systemctl start docker
        sleep 5
    fi

    docker compose --env-file "$ENV_FILE" -f "$COMPOSE_FILE" pull
    docker compose --env-file "$ENV_FILE" -f "$COMPOSE_FILE" up -d --remove-orphans
    wait_for_healthy "db" 120 || exit 1
    wait_for_healthy "nextcloud" 600 || exit 1
}

wait_for_nextcloud_install() {
    local NC_CID=$(get_nc_cid)
    [[ -z "$NC_CID" ]] && return 1

    echo "Waiting for Nextcloud internal installation to complete..."
    # Increased to 120 retries (10 minutes) for slower I/O
    local retries=120 
    
    while [[ $retries -gt 0 ]]; do
        # Check occ status for 'installed: true'
        # We redirect stderr because occ throws errors if not installed yet
        if docker exec --user www-data "$NC_CID" php occ status 2>&1 | grep -q "installed: true"; then
            echo "✅ Nextcloud is fully installed."
            return 0
        fi
        
        # progress indicator
        if (( retries % 6 == 0 )); then
            echo "   ...waiting for auto-install ($retries retries left)"
        fi
        
        sleep 5
        ((retries--))
    done

    echo "[ERROR] Nextcloud installation timed out."
    docker logs "$NC_CID" | tail -n 50
    return 1
}

configure_nextcloud_https() {
    echo "[6/10] Applying reverse proxy HTTPS configuration..."
    local NC_CID=$(docker compose -f "$COMPOSE_FILE" ps -q nextcloud)
    [[ -z "$NC_CID" ]] && die "Nextcloud container not ready."

    # Use shared function to ensure install is done before config
    wait_for_nextcloud_install || die "Nextcloud installation failed to complete."

    # Now safe to run config commands
    docker exec --user www-data "$NC_CID" php occ config:system:set overwriteprotocol --value=https || die "Failed to set overwriteprotocol."
    docker exec --user www-data "$NC_CID" php occ config:system:set trusted_proxies 0 --value="$TRUSTED_PROXIES_0" || die "Failed to set trusted_proxies 0."
    docker exec --user www-data "$NC_CID" php occ config:system:set trusted_proxies 1 --value="$TRUSTED_PROXIES_1" || die "Failed to set trusted_proxies 1."
    docker exec --user www-data "$NC_CID" php occ config:system:set trusted_domains 1 --value="$NEXTCLOUD_TRUSTED_DOMAINS" || die "Failed to set trusted_domains 1."
    # Also apply subnet trust if applicable (Headless/Cloudflare)
    configure_docker_subnet_trust
    
    echo "Restarting Nextcloud service..."
    docker compose -f "$COMPOSE_FILE" restart nextcloud
    wait_for_healthy "nextcloud" 120 || exit 1
}
     
validate_setup() {
    echo "[10/10] Validating setup..."
    sleep 10
    if curl -f -k "https://$CF_HOSTNAME/status.php" >/dev/null 2>&1; then
        echo "✅ Nextcloud is accessible at: https://$CF_HOSTNAME"
    else
        echo "⚠️ Setup complete, but accessibility check failed. Check Cloudflare tunnel and firewall."
    fi
}

backup() {
    set -euo pipefail

    # --- Configuration and Initialization ---
    REPO_DIR="/opt/raspi-nextcloud-setup"
    ENV_FILE="$REPO_DIR/.env"
    LOCK_FILE="/var/run/nextcloud-backup.lock"
    [[ -f "$ENV_FILE" ]] || { echo "Missing $ENV_FILE"; exit 1; }
    # shellcheck disable=SC1090
    source "$ENV_FILE"

    # Validate required variables
    : "${BACKUP_RETENTION:?BACKUP_RETENTION not set in .env}"
    : "${NEXTCLOUD_DATA_DIR:?NEXTCLOUD_DATA_DIR not set}"
    : "${MYSQL_USER:?}"
    : "${MYSQL_PASSWORD:?}"
    : "${MYSQL_DATABASE:?}"

    auto_mount_backup() {
        if mountpoint -q "$BACKUP_MOUNTDIR"; then return 0; fi
        mount "$BACKUP_MOUNTDIR" >> "$BACKUP_LOG_FILE" 2>&1 || {
            echo "[!] Failed to mount $BACKUP_MOUNTDIR. Ensure drive is connected." >> "$BACKUP_LOG_FILE"
            exit 1
        }
    }

    # --- Locking ---
    exec 200>"$LOCK_FILE"
    flock -n 200 || { echo "Backup is already running."; exit 1; }

    # --- Staging and Cleanup ---
    DATE="$(date +'%Y-%m-%d_%H-%M-%S')"
    STAGING_DIR=$(mktemp -d -p "$BACKUP_MOUNTDIR" staging_XXXXXX)  # Secure temp
    ARCHIVE_PATH="$BACKUP_MOUNTDIR/nextcloud_backup_${DATE}.tar.gz"

    # TRAP to ensure cleanup and maintenance mode is turned off on exit/error
    cleanup() {
        echo "[*] Cleaning up... Ensuring maintenance mode is disabled."
        set_maintenance_mode "--off" "$BACKUP_LOG_FILE" || true # Suppress errors
        # Remove staging directory
        if [[ -d "$STAGING_DIR" ]]; then
            rm -rf "$STAGING_DIR"
            echo "[*] Staging directory removed."
        fi
        rm -f "$LOCK_FILE"  # Ensure lock release
    }
    trap cleanup EXIT INT TERM

    # --- Mount Backup Drive ---
    auto_mount_backup

    # --- Main Backup Logic ---
    echo "=== Starting Nextcloud Backup: $DATE ==="

    mkdir -p "$STAGING_DIR/data" "$STAGING_DIR/db" "$STAGING_DIR/config"
    NC_CID="$(docker compose -f "$REPO_DIR/docker-compose.yml" ps -q nextcloud)"
    DB_CID="$(docker compose -f "$REPO_DIR/docker-compose.yml" ps -q db)"

    # Enhanced container checks
    if [[ -z "$NC_CID" ]] || ! docker inspect --format '{{.State.Running}}' "$NC_CID" 2>/dev/null | grep -q '^true$'; then
        echo "[!] Nextcloud container not found or not running. Aborting."
        exit 1
    fi
    if [[ -z "$DB_CID" ]] || ! docker inspect --format '{{.State.Running}}' "$DB_CID" 2>/dev/null | grep -q '^true$'; then
        echo "[!] DB container not found or not running. Aborting."
        exit 1
    fi

    echo "[1/6] Checking for sufficient disk space..."
    ESTIMATED_DATA_KB=$(du -sk "$NEXTCLOUD_DATA_DIR" | awk '{print $1}')
    # Dynamically estimate DB size (fallback to 100MB if query fails)
    ESTIMATED_DB_KB=$(docker exec "$DB_CID" mariadb -u "$MYSQL_USER" -p"$MYSQL_PASSWORD" -e "SELECT ROUND(SUM(data_length + index_length) / 1024) AS size_kb FROM information_schema.tables WHERE table_schema='$MYSQL_DATABASE';" 2>/dev/null | tail -1 || echo "102400")
    ESTIMATED_CONFIG_KB=51200  # Conservative for config (50MB)
    ESTIMATED_UNCOMPRESSED_KB=$((ESTIMATED_DATA_KB + ESTIMATED_DB_KB + ESTIMATED_CONFIG_KB))
    # Peak: ~2.0x for staging + archive (assuming no compression; adjust multiplier if needed)
    ESTIMATED_PEAK_KB=$((ESTIMATED_UNCOMPRESSED_KB * 2))
    AVAILABLE_KB=$(df --output=avail "$BACKUP_MOUNTDIR" | tail -n1)
    echo "[INFO] Estimated uncompressed: $((ESTIMATED_UNCOMPRESSED_KB / 1024)) MB, Peak: $((ESTIMATED_PEAK_KB / 1024)) MB, Available: $((AVAILABLE_KB / 1024)) MB" >> "$BACKUP_LOG_FILE"
    if [ "$AVAILABLE_KB" -lt "$ESTIMATED_PEAK_KB" ]; then
        echo "[!] Not enough free space. Available: $((AVAILABLE_KB / 1024)) MB, Needed (peak): $((ESTIMATED_PEAK_KB / 1024)) MB. Aborting."
        exit 1
    fi

    echo "[2/6] Enabling maintenance mode..."
    set_maintenance_mode "--on" "$BACKUP_LOG_FILE" || die "Failed to enable maintenance mode."

    echo "[3/6] Dumping database..."
    docker run --rm \
      --network container:"$DB_CID" \
      -e MYSQL_PWD="$MYSQL_PASSWORD" \
      mysql:8 \
      mysqldump --column-statistics=0 -h 127.0.0.1 -u "$MYSQL_USER" "$MYSQL_DATABASE" \
      > "$STAGING_DIR/db/nextcloud.sql"

    echo "[4/6] Copying data and config..."
    if ! rsync -a --delete "$NEXTCLOUD_DATA_DIR"/ "$STAGING_DIR/data/" 2>> "$BACKUP_LOG_FILE"; then
        echo "[!] Rsync failed. Check permissions or disk space." >> "$BACKUP_LOG_FILE"
        exit 1
    fi
    NC_HTML_VOLUME=$(docker inspect "$NC_CID" --format '{{ range .Mounts }}{{ if eq .Destination "/var/www/html" }}{{ .Name }}{{ end }}{{ end }}')
    docker run --rm -v "${NC_HTML_VOLUME}:/volume:ro" -v "$STAGING_DIR/config":/backup alpine \
        sh -c "cp -a /volume/config/. /backup/"

    echo "[5/6] Creating compressed archive..."
    if ! tar -C "$STAGING_DIR" -czf "$ARCHIVE_PATH" data db config 2>> "$BACKUP_LOG_FILE"; then
        echo "[!] Tar failed (possibly out of space). Partial archive may exist: $ARCHIVE_PATH" >> "$BACKUP_LOG_FILE"
        rm -f "$ARCHIVE_PATH"  # Clean partial file idempotently
        exit 1
    fi
    sync

    # Maintenance mode is disabled by the 'trap cleanup' function

    echo "[6/6] Applying backup retention policy (keep last $BACKUP_RETENTION)..."
    OLD_BACKUPS=$(ls -tp "$BACKUP_MOUNTDIR"/nextcloud_backup_*.tar.gz 2>/dev/null | tail -n +$((BACKUP_RETENTION+1)))
    if [[ -n "$OLD_BACKUPS" ]]; then
        echo "[INFO] Deleting old backups: $OLD_BACKUPS" >> "$BACKUP_LOG_FILE"
    fi
    ls -tp "$BACKUP_MOUNTDIR"/nextcloud_backup_*.tar.gz 2>/dev/null | tail -n +$((BACKUP_RETENTION+1)) | xargs -r rm --
    echo "--- Backup Complete: $ARCHIVE_PATH ---"
    rm -f "$LOCK_FILE"  # Redundant lock release for idempotence
}

restore() {
    set -euo pipefail

    # --- Configuration and Initialization ---
    REPO_DIR="/opt/raspi-nextcloud-setup"
    ENV_FILE="$REPO_DIR/.env"
    COMPOSE_FILE="$REPO_DIR/docker-compose.yml"
    [[ -f "$ENV_FILE" ]] || { echo "Missing $ENV_FILE"; exit 1; }
    # shellcheck disable=SC1090
    source "$ENV_FILE"

    # Validate required variables
    : "${NEXTCLOUD_DATA_DIR:?NEXTCLOUD_DATA_DIR not set}"
    : "${MYSQL_USER:?}"
    : "${MYSQL_PASSWORD:?}"
    : "${MYSQL_DATABASE:?}"
    : "${MYSQL_ROOT_PASSWORD:?}"

    # --- Temporary Directory and Cleanup ---
    TMP_DIR=$(mktemp -d -t nextcloud-restore-XXXXXX)
    trap 'echo "[*] Cleaning up temporary directory..."; rm -rf "$TMP_DIR"' EXIT INT TERM

    # --- Mount Backup Drive ---
    mkdir -p "$BACKUP_MOUNTDIR"
    if ! mountpoint -q "$BACKUP_MOUNTDIR"; then
      mount "$BACKUP_MOUNTDIR" || {
        echo "[!] Failed to mount $BACKUP_MOUNTDIR. Aborting."
        exit 1
      }
    fi

    # --- Handle --no-prompt flag ---
    no_prompt=false
    for arg in "$@"; do
        if [[ "$arg" == "--no-prompt" ]]; then
            no_prompt=true
        fi
    done

    # --- Select Backup File ---
    if [[ $# -ge 1 && "$1" != "--no-prompt" ]]; then
      BACKUP_FILE="$1"
    else
      echo "[*] No backup file specified. Finding the latest..."
      BACKUP_FILE="$(find "$BACKUP_MOUNTDIR" -maxdepth 1 -name 'nextcloud_backup_*.tar.gz' -print0 | xargs -0 ls -t | head -n1)"
      [[ -n "$BACKUP_FILE" ]] || { echo "No backups found in $BACKUP_MOUNTDIR"; exit 1; }
    fi
    [[ -f "$BACKUP_FILE" ]] || { echo "Backup not found: $BACKUP_FILE"; exit 1; }
    echo "[*] Selected backup for restore: $BACKUP_FILE"

    # --- User Confirmation ---
    echo "!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! WARNING !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!"
    echo "This will COMPLETELY OVERWRITE the following:"
    echo "  - Nextcloud data: $NEXTCLOUD_DATA_DIR"
    echo "  - Nextcloud config"
    echo "  - MariaDB database: $MYSQL_DATABASE"
    echo "This operation is irreversible."
    if $no_prompt; then
        CONFIRM="OVERWRITE"
    else
        read -rp "Type 'OVERWRITE' to proceed: " CONFIRM
    fi
    [[ "${CONFIRM^^}" == "OVERWRITE" ]] || { echo "Restore aborted by user."; exit 0; }

    # --- Main Restore Logic ---
    echo "[1/6] Stopping and removing Nextcloud container..."
    docker compose -f "$REPO_DIR/docker-compose.yml" rm -sf nextcloud

    echo "[2/6] Extracting backup to temporary location..."
    tar -xzf "$BACKUP_FILE" -C "$TMP_DIR"
    [[ -d "$TMP_DIR/data" && -f "$TMP_DIR/db/nextcloud.sql" && -d "$TMP_DIR/config" ]] || \
      { echo "Backup archive is malformed (missing data/, db/, or config/ dirs)."; exit 1; }

    echo "[3/6] Restoring data and config directories..."
    mkdir -p "$NEXTCLOUD_DATA_DIR"
    rsync -a --delete "$TMP_DIR/data/" "$NEXTCLOUD_DATA_DIR/"
    # Get volume name idempotently (even if container is stopped)
    NC_HTML_VOLUME=$(docker volume ls -q -f name=raspi-nextcloud-setup_nextcloud_html)
    docker run --rm -v "${NC_HTML_VOLUME}:/volume" -v "$TMP_DIR/config:/backup:ro" alpine \
        sh -c "rm -rf /volume/config/* && cp -a /backup/. /volume/config/"

    echo "[4/6] Resetting and restoring database..."
    docker compose -f "$REPO_DIR/docker-compose.yml" up -d db
    echo "[*] Waiting for DB container to be healthy..."
    wait_for_healthy "db" 120 || exit 1
    DB_CID="$(docker compose -f "$REPO_DIR/docker-compose.yml" ps -q db)"
    NETWORK_NAME=$(docker inspect "$DB_CID" --format='{{range $k, $v := .NetworkSettings.Networks}}{{$k}}{{end}}')

    # Drop and recreate database to ensure idempotent restore
    docker run --rm \
      --network "$NETWORK_NAME" \
      -e MYSQL_PWD="$MYSQL_ROOT_PASSWORD" \
      mysql:8 \
      sh -c "mysql -h db -u root -e \"DROP DATABASE IF EXISTS $MYSQL_DATABASE; CREATE DATABASE $MYSQL_DATABASE;\""

    # Import dump using mysql:8 client container
    docker run --rm \
      --network "$NETWORK_NAME" \
      -e MYSQL_PWD="$MYSQL_ROOT_PASSWORD" \
      -v "$TMP_DIR/db/nextcloud.sql:/restore.sql" \
      mysql:8 \
      sh -c "mysql -h db -u root $MYSQL_DATABASE < /restore.sql"

    echo "[5/6] Starting Nextcloud service..."
    docker compose -f "$REPO_DIR/docker-compose.yml" up -d nextcloud

    echo "[6/6] Verifying services and exiting maintenance mode..."
    echo "[*] Waiting for Nextcloud container to be healthy..."
    wait_for_healthy "nextcloud" 180 || exit 1
    NC_CID_NEW="$(docker compose -f "/opt/raspi-nextcloud-setup/docker-compose.yml" ps -q nextcloud)"
    docker exec -u www-data "$NC_CID_NEW" php occ maintenance:mode --off || true

    # Temp dir is cleaned up by the trap
    echo "=== Restore Complete From: $BACKUP_FILE ==="
}


install_backup_cron() {
    local minute="$1" hour="$2" day_of_month="$3" month="$4" day_of_week="$5"
    local cron_expr="$minute $hour $day_of_month $month $day_of_week"

    local cron_content="# Run Nextcloud backup at $cron_expr\n$cron_expr root /usr/local/sbin/raspi-cloud --backup >> $BACKUP_LOG_FILE 2>&1\n"
    if [[ -f "$CRON_FILE" && $(cat "$CRON_FILE") == *"$cron_expr"* ]]; then
        echo "Cron job already up-to-date for schedule $cron_expr."
    else
        echo -e "$cron_content" > "$CRON_FILE"
        chmod 644 "$CRON_FILE"
        echo "Cron job updated for schedule $cron_expr."
    fi
}

system_health_check() {
    touch "$HEALTH_LOG_FILE"
    chmod 644 "$HEALTH_LOG_FILE"

    (
        echo "=== System Health Check Started at $(date) ==="

        # Docker status
        echo "[CHECK] Docker service:"
        if systemctl is-active --quiet docker; then
            echo "  ✅ Docker is running"
        else
            echo "  ❌ Docker is not running"
        fi

        # Stack status
        echo "[CHECK] Nextcloud stack:"
        if is_stack_running; then
            echo "  ✅ Stack is running"
            local nc_cid db_cid
            nc_cid=$(get_nc_cid)
            db_cid=$(docker compose -f "$COMPOSE_FILE" ps -q db 2>/dev/null)
            if [[ -n "$nc_cid" && -n "$db_cid" ]]; then
                local nc_health db_health
                nc_health=$(docker inspect --format="{{if .State.Health}}{{.State.Health.Status}}{{end}}" "$nc_cid" 2>/dev/null || echo "unknown")
                db_health=$(docker inspect --format="{{if .State.Health}}{{.State.Health.Status}}{{end}}" "$db_cid" 2>/dev/null || echo "unknown")
                echo "  Nextcloud health: $nc_health"
                echo "  DB health: $db_health"
            fi
        else
            echo "  ❌ Stack is not running"
        fi

        # Disk space
        echo "[CHECK] Disk usage:"
        df -h / | tail -1 | awk '{print "  Root: " $5 " used (" $4 " available)"}'
        source "$ENV_FILE" 2>/dev/null || true
        local backup_dir="$BACKUP_MOUNTDIR"
        if mountpoint -q "$backup_dir"; then
            df -h "$backup_dir" | tail -1 | awk '{print "  Backup: " $5 " used (" $4 " available)"}'
        else
            echo "  Backup dir not mounted"
        fi

        # Backup drive mount
        echo "[CHECK] Backup drive:"
        if mountpoint -q "$backup_dir"; then
            echo "  ✅ Mounted at $backup_dir"
        else
            echo "  ❌ Not mounted"
        fi

        # Cron job
        echo "[CHECK] Backup cron:"
        if [[ -f "$CRON_FILE" ]]; then
            echo "  ✅ Installed: $(head -1 "$CRON_FILE")"
        else
            echo "  ❌ Not installed"
        fi

        # Log errors (last 50 lines)
        echo "[CHECK] Recent errors in logs:"
        grep -i "error\|fail\|warn" "$MAIN_LOG_FILE" "$BACKUP_LOG_FILE" "$RESTORE_LOG_FILE" 2>/dev/null | tail -20 || echo "  No recent errors"

        # Nextcloud occ status (if running)
        if [[ -n "$nc_cid" ]]; then
            echo "[CHECK] Nextcloud status:"
            docker exec -u www-data "$nc_cid" php occ status 2>/dev/null || echo "  Could not get status."
        fi

        echo "=== Health Check Completed at $(date) ==="
    ) >> "$HEALTH_LOG_FILE" 2>&1

    dialog --title "System Health Check" --textbox "$HEALTH_LOG_FILE" 25 80
}

# --- Maintenance Menu ---
maintenance_menu() {
    while true; do
        local choice
        choice=$(dialog --stdout \
            --title "Maintenance Menu" \
            --menu "Select an action (or 0 to return):" $HEIGHT $WIDTH $CHOICE_HEIGHT \
            1 "Toggle Maintenance Mode" \
            2 "Scan User Files (files:scan)" \
            3 "Expand Filesystem with LVM" \
            4 "Configure Watchdog" \
            5 "Disable Wireless (WiFi/Bluetooth)" \
            6 "Setup Nextcloud Cronjob" \
            0 "Back to Main Menu")
        local retval=$?
        if [ $retval -ne 0 ] || [ "$choice" = "0" ]; then
            return 0  # Explicit back or cancel -> return to main
        fi

        case "$choice" in
            1) toggle_maintenance_mode ;;
            2) run_files_scan ;;
            3) lvm_storage_extension ;;
            4) configure_watchdog ;;
            5) disable_wireless ;;
            6) setup_nextcloud_cron ;;
        esac
        reset_terminal  # Clean after actions
    done
}

toggle_maintenance_mode() {
    if ! is_stack_running; then
        dialog --title "Error" --msgbox "Nextcloud stack is not running." 8 50
        return 1
    fi

    local current_status
    current_status=$(get_maintenance_status)

    local status
    case "$current_status" in
        0) status="enabled" ;;
        1) status="disabled" ;;
        *)
            dialog --title "Error" --msgbox "Failed to query maintenance mode." 8 50
            return 1
            ;;
    esac

    local new_mode new_status
    if [[ "$status" == "enabled" ]];
    then
        new_mode="--off"
        new_status="disabled"
    else
        new_mode="--on"
        new_status="enabled"
    fi

    dialog --title "Confirm" --yesno "Maintenance mode is currently $status. Do you want to turn it $new_status?" 10 60
    if [ $? -eq 0 ];
    then
        if set_maintenance_mode "$new_mode" >/dev/null 2>&1;
        then
            dialog --title "Success" --msgbox "Maintenance mode is now $new_status." 8 40
        else
            dialog --title "Error" --msgbox "Failed to toggle maintenance mode." 8 50
        fi
    fi
    reset_terminal
}

run_files_scan() {
    if ! is_stack_running; then
        dialog --title "Error" --msgbox "Nextcloud stack is not running." 8 50
        return 1
    fi
    
    local user
    user=$(dialog --stdout \
        --inputbox "Enter username to scan (or '--all' for all users):" 8 60 "")
    local retval=$?
    if [ $retval -ne 0 ] || [ -z "$user" ]; then
        return 0
    fi

    dialog --title "Confirm Scan" --yesno "Scan files for user: '$user'?" 8 50
    if [ $? -eq 0 ]; then
        local nc_cid
        nc_cid=$(get_nc_cid)
        if [[ -z "$nc_cid" ]]; then
            dialog --title "Error" --msgbox "Nextcloud container not found." 8 50
            return 1
        fi
        (
            echo "=== File Scan Started at $(date) ===" 
            docker exec -u www-data "$nc_cid" php occ files:scan "$user"
            echo "=== File Scan Completed at $(date) ===" 
        ) >> "$MAIN_LOG_FILE" 2>&1 &  # Append to preserve history
        local pid=$!
        
        dialog --title "File Scan Log" --tailbox "$MAIN_LOG_FILE" 25 80 &
        local tail_pid=$!
        
        wait_for_completion "$pid" "Scan in Progress" "Scanning user files... (Check log for details)"
        kill "$tail_pid" 2>/dev/null || true
        reset_terminal
        
        dialog --title "Complete" --msgbox "File scan for '$user' finished. Check log for details." 8 60
    fi
}

get_ssd_drives() {
    lsblk -d -o NAME -n | grep -E '^(nvme[0-9]+n[0-9]+|sd[a-z])$' | sort
}

# New: Flash OS to NVMe and Switch Boot (For Fresh SD to NVMe)
flash_to_nvme() {
    local root_dev
    root_dev=$(findmnt -o SOURCE / | tail -1 | cut -d'[' -f1)
    if [[ $root_dev != /dev/mmcblk* ]]; then
        die "This option is only available when booted from SD card."
    fi

    local drives
    drives=$(get_ssd_drives)
    mapfile -t drive_array <<< "$drives"
    if [ ${#drive_array[@]} -eq 0 ]; then
        die "No target SSD/NVMe drive detected."
    fi

    local target_name
    if [ ${#drive_array[@]} -eq 1 ]; then
        target_name=${drive_array[0]}
    else
        local options=()
        for i in "${!drive_array[@]}"; do
            local size
            size=$(lsblk -d -o SIZE -n /dev/"${drive_array[$i]}")
            options+=("$((i+1))" "${drive_array[$i]} ($size)")
        done
        local choice
        choice=$(dialog --stdout --title "Select Target Drive" --menu "Choose the drive to flash to:" 15 50 5 "${options[@]}")
        if [ $? -ne 0 ]; then return 0; fi
        target_name=${drive_array[$((choice-1))]}
    fi

    local part_suffix
    if [[ $target_name =~ ^nvme ]]; then part_suffix="p"; else part_suffix=""; fi
    local target_root_part="/dev/${target_name}${part_suffix}2"

    dialog --title "Warning" --yesno "This will clone the current OS from SD to /dev/$target_name, set boot priority, and reboot. The drive will be overwritten. Proceed?" 10 60
    if [ $? -ne 0 ]; then return 0; fi

    (
        echo "=== Flash to $target_name Started at $(date) ===" >> "$FLASH_LOG_FILE"

        install_dependencies >> "$FLASH_LOG_FILE" 2>&1        
        git clone https://github.com/geerlingguy/rpi-clone.git /tmp/rpi-clone >> "$FLASH_LOG_FILE" 2>&1 || die "Failed to clone rpi-clone."
        cd /tmp/rpi-clone
        sudo cp rpi-clone rpi-clone-setup /usr/local/bin >> "$FLASH_LOG_FILE" 2>&1 || die "Failed to copy rpi-clone scripts."
        sudo chmod +x /usr/local/bin/rpi-clone /usr/local/bin/rpi-clone-setup >> "$FLASH_LOG_FILE" 2>&1 || die "Failed to make rpi-clone executable."
        rpi-clone "$target_name" -f -U -v >> "$FLASH_LOG_FILE" 2>&1 || die "Clone failed."
        
        # Add auto-start TUI on first boot
        mkdir -p /mnt/target
        mount "$target_root_part" /mnt/target >> "$FLASH_LOG_FILE" 2>&1 || die "Failed to mount new root."
        echo "if [ -f /first_boot_tui ]; then sudo raspi-cloud; rm /first_boot_tui; fi" >> /mnt/target/etc/rc.local
        touch /mnt/target/first_boot_tui
        umount /mnt/target

        # Set boot order
        local boot_code
        if [[ $target_name =~ ^nvme ]]; then boot_code=B3; else boot_code=B2; fi
        raspi-config nonint do_boot_order "$boot_code" >> "$FLASH_LOG_FILE" 2>&1 || die "Failed to set boot order."

        echo "=== Flash to $target_name Completed at $(date) ===" >> "$FLASH_LOG_FILE"
    ) & 
    local pid=$!

    dialog --title "Flash Log" --tailbox "$FLASH_LOG_FILE" 25 80 &
    local tail_pid=$!

    wait_for_completion "$pid" "Flash to Drive in Progress" "Cloning and configuring... (Check log)"
    kill "$tail_pid" 2>/dev/null || true
    reset_terminal

    dialog --title "Complete" --yesno "Flash done. Reboot to $target_name now? (Remove SD card after shutdown)" 8 60
    if [ $? -eq 0 ]; then sudo reboot; fi

    dialog --title "Flash Log" --textbox "$FLASH_LOG_FILE" 25 80
}

# New: LVM Storage Extension Function (Phase-Aware, Automated)
lvm_storage_extension() {
    local drives
    drives=$(get_ssd_drives)
    mapfile -t drive_array <<< "$drives"
    if [ ${#drive_array[@]} -ne 2 ]; then
        die "Exactly two SSD/NVMe drives required for LVM extension."
    fi

    local root_dev_full
    root_dev_full=$(findmnt -no SOURCE /)
    local root_dev_short=${root_dev_full#/dev/mapper/} # Get clean name like rpi--vg-root--lv

    dialog --title "Warning" --yesno "This will extend storage with LVM across two drives, creating a single large filesystem. This process is complex and involves multiple reboots. Ensure you have a fresh Raspberry Pi OS Bookworm Lite SD card available for the intermediate step. It is highly recommended to back up all data first. Proceed?" 15 70
    if [ $? -ne 0 ]; then return 0; fi

    (
        echo "=== LVM Migration Started at $(date) on root: $root_dev_full ===" >> "$LVM_LOG_FILE"

        # --- Phase 1: Preparation on the initial (non-LVM) SSD/NVMe drive ---
        if [[ "$root_dev_full" =~ ^/dev/(nvme|sd) ]]; then
            echo "[Phase 1] Preparing the initial drive for migration..." >> "$LVM_LOG_FILE"
            local current_root_drive
            current_root_drive=$(lsblk -no pkname "$root_dev_full")
            local other_drive=""
            for drive in "${drive_array[@]}"; do
                if [[ "$drive" != "$current_root_drive" ]]; then
                    other_drive=$drive
                    break
                fi
            done
            [[ -z "$other_drive" ]] && die "Could not determine the other drive for initramfs preparation."

            echo "Current root drive: $current_root_drive. The other drive is: $other_drive." >> "$LVM_LOG_FILE"
            install_dependencies >> "$LVM_LOG_FILE" 2>&1

            sed -i 's/^MODULES=.*/MODULES=most/' /etc/initramfs-tools/initramfs.conf
            # Add required modules for LVM on NVMe/USB
            cat <<EOF >> /etc/initramfs-tools/modules
nvme_core
nvme
dm-mod
usb_storage
sd_mod
EOF
            sort -u /etc/initramfs-tools/modules -o /etc/initramfs-tools/modules
            mkdir -p /etc/initramfs-tools/scripts/local-top
            # Dynamically create the initramfs script to wait for the correct secondary drive
            cat <<EOF > /etc/initramfs-tools/scripts/local-top/force_lvm
#!/bin/sh
PREREQ=""
prereqs() { echo "\$PREREQ"; }
case "\$1" in prereqs) prereqs; exit 0;; esac
. /scripts/functions
modprobe -q nvme_core >/dev/null 2>&1
modprobe -q nvme >/dev/null 2>&1
modprobe -q dm-mod >/dev/null 2>&1
log_begin_msg "Waiting for secondary drive ($other_drive) up to 30s"
for i in \$(seq 1 30); do
    if [ -b /dev/$other_drive ]; then
        log_success_msg "Secondary drive found after \$i seconds"
        break
    fi
    sleep 1
done
lvm pvscan --cache
lvm vgscan --mknodes
lvm vgchange -ay rpi-vg || true
EOF
            chmod +x /etc/initramfs-tools/scripts/local-top/force_lvm
            update-initramfs -u -k "$(uname -r)" >> "$LVM_LOG_FILE" 2>&1 || die "Failed to update initramfs."
            cp "/boot/initrd.img-$(uname -r)" "$BOOT_PARTITION/" || die "Failed to copy initrd."
            if ! grep -q "initramfs initrd.img-$(uname -r) followkernel" "$BOOT_PARTITION/config.txt"; then
                echo -e "\n[all]" >> "$BOOT_PARTITION/config.txt"
                echo "initramfs initrd.img-$(uname -r) followkernel" >> "$BOOT_PARTITION/config.txt"
            fi
            echo "[Phase 1 Complete] System prepared for migration from SD card." >> "$LVM_LOG_FILE"

        # --- Phase 2: Migration performed from a temporary SD card OS ---
        elif [[ "$root_dev_full" == /dev/mmcblk* ]]; then
            echo "[Phase 2] Migrating from original drive to new LVM volume..." >> "$LVM_LOG_FILE"
            
            # Robustly identify source and target drives by checking for a filesystem on partition 2
            local source_drive="" target_drive=""
            local source_suffix target_suffix
            for drive in "${drive_array[@]}"; do
                suffix=$( [[ $drive =~ ^nvme ]] && echo "p" || echo "" )
                if blkid "/dev/${drive}${suffix}2" &>/dev/null; then
                    source_drive=$drive
                    source_suffix=$suffix
                else
                    target_drive=$drive
                    target_suffix=$suffix
                fi
            done
            [[ -z "$source_drive" || -z "$target_drive" ]] && die "Could not identify source or target drive."
            echo "Source drive: $source_drive, Target drive: $target_drive" >> "$LVM_LOG_FILE"

            local original_root_partuuid
            original_root_partuuid=$(blkid -o value -s PARTUUID "/dev/${source_drive}${source_suffix}2")
            [[ -z "$original_root_partuuid" ]] && die "Could not determine PARTUUID of source drive /dev/${source_drive}${source_suffix}2."

            install_dependencies >> "$LVM_LOG_FILE" 2>&1            
            
            echo "Setting up LVM on target drive $target_drive..." >> "$LVM_LOG_FILE"
            # Clean up and create LVM on the target drive
            vgremove -f rpi-vg 2>/dev/null || true
            pvremove -f "/dev/$target_drive" 2>/dev/null || true
            wipefs -a "/dev/$target_drive" >> "$LVM_LOG_FILE" 2>&1
            parted --script "/dev/$target_drive" mklabel gpt >> "$LVM_LOG_FILE" 2>&1
            pvcreate -f "/dev/$target_drive" >> "$LVM_LOG_FILE" 2>&1 || die "Failed to create PV on $target_drive."
            vgcreate rpi-vg "/dev/$target_drive" >> "$LVM_LOG_FILE" 2>&1 || die "Failed to create VG 'rpi-vg'."
            lvcreate -n root-lv -l 100%FREE rpi-vg >> "$LVM_LOG_FILE" 2>&1 || die "Failed to create LV 'root-lv'."
            mkfs.ext4 -L rootfs /dev/rpi-vg/root-lv >> "$LVM_LOG_FILE" 2>&1 || die "Failed to format LV."
            
            echo "Copying data from $source_drive to LVM..." >> "$LVM_LOG_FILE"
            mkdir -p /mnt/old_root /mnt/new_root
            mount "/dev/${source_drive}${source_suffix}2" /mnt/old_root >> "$LVM_LOG_FILE" 2>&1 || die "Failed to mount old root."
            mount /dev/rpi-vg/root-lv /mnt/new_root >> "$LVM_LOG_FILE" 2>&1 || die "Failed to mount new LVM root."
            rsync -aAXv --delete /mnt/old_root/ /mnt/new_root/ >> "$LVM_LOG_FILE" 2>&1 || die "Rsync failed."
            
            echo "Configuring boot files for LVM..." >> "$LVM_LOG_FILE"
            mount "/dev/${source_drive}${source_suffix}1" "/mnt/new_root$BOOT_PARTITION" >> "$LVM_LOG_FILE" 2>&1 || die "Failed to mount boot partition."
            # Update fstab and cmdline.txt to point to the new LVM root device
            sed -i "s|PARTUUID=$original_root_partuuid|/dev/mapper/rpi--vg-root--lv|" /mnt/new_root/etc/fstab || die "fstab update failed."
            sed -i "s|root=PARTUUID=[^ ]*|root=/dev/mapper/rpi--vg-root--lv rootfstype=ext4 rootwait|" "/mnt/new_root$BOOT_PARTITION/cmdline.txt" || die "cmdline update failed."
            
            umount "/mnt/new_root$BOOT_PARTITION"
            umount /mnt/new_root
            umount /mnt/old_root
            echo "[Phase 2 Complete] Set boot to the original source drive ($source_drive) via raspi-config, remove SD, and reboot." >> "$LVM_LOG_FILE"

        # --- Phase 3: Finalization on the new LVM root filesystem ---
        elif [[ "$root_dev_short" == "rpi--vg-root--lv" ]]; then
            echo "[Phase 3] Finalizing LVM setup by incorporating the original drive..." >> "$LVM_LOG_FILE"
            
            # Get current PVs
            mapfile -t pvs_list < <(pvs --noheadings -o pv_name | awk '{print $1}')
            
            # Find the partition or whole disk to add (not in current PVs)
            local add_dev=""
            for drive in "${drive_array[@]}"; do
                local suffix=$( [[ $drive =~ ^nvme ]] && echo "p" || echo "" )
                local candidate_dev="/dev/${drive}${suffix}2"
                if [ -b "$candidate_dev" ] && ! printf '%s\n' "${pvs_list[@]}" | grep -q "^$candidate_dev$"; then
                    add_dev="$candidate_dev"
                    break
                fi
                # Check whole disk if partition not present
                candidate_dev="/dev/$drive"
                if [ -b "$candidate_dev" ] && ! printf '%s\n' "${pvs_list[@]}" | grep -q "^$candidate_dev$"; then
                    add_dev="$candidate_dev"
                    break
                fi
            done
            [[ -z "$add_dev" ]] && { echo "No suitable device found to add to VG. Skipping Phase 3." >> "$LVM_LOG_FILE"; return 0; }
            echo "Device to add to LVM: $add_dev" >> "$LVM_LOG_FILE"

            install_dependencies >> "$LVM_LOG_FILE" 2>&1
            
            echo "Wiping and adding $add_dev to volume group..." >> "$LVM_LOG_FILE"
            umount "$add_dev" 2>/dev/null || true
            wipefs -a -f "$add_dev" >> "$LVM_LOG_FILE" 2>&1 || die "Wipefs failed on $add_dev."
            pvcreate -f "$add_dev" >> "$LVM_LOG_FILE" 2>&1 || die "PV create failed on $add_dev."
            vgextend rpi-vg "$add_dev" >> "$LVM_LOG_FILE" 2>&1 || die "VG extend failed."
            
            echo "Extending logical volume and resizing filesystem..." >> "$LVM_LOG_FILE"
            lvextend -l +100%FREE /dev/rpi-vg/root-lv >> "$LVM_LOG_FILE" 2>&1 || die "LV extend failed."
            resize2fs /dev/rpi-vg/root-lv >> "$LVM_LOG_FILE" 2>&1 || die "Resize failed."
            e2fsck -f -y /dev/rpi-vg/root-lv >> "$LVM_LOG_FILE" 2>&1 || true
            echo "[Phase 3 Complete] Storage has been successfully extended across both drives." >> "$LVM_LOG_FILE"

        else
            die "Unknown root device: $root_dev_full. Cannot determine LVM migration phase. Aborting."
        fi

        echo "=== LVM Migration Phase Completed at $(date) ===" >> "$LVM_LOG_FILE"
    ) &
    local pid=$!

    dialog --title "LVM Log" --tailbox "$LVM_LOG_FILE" 25 80 &
    local tail_pid=$!

    wait_for_completion "$pid" "LVM Extension in Progress" "Processing phase... (Check log for details)"
    kill "$tail_pid" 2>/dev/null || true
    reset_terminal

    # --- Phase-specific prompts for next steps ---
    if [[ "$root_dev_full" =~ ^/dev/(nvme|sd) ]]; then
        dialog --title "Next Steps: Reboot to SD Card" --msgbox "Phase 1 is complete. Please perform the following steps:\n\n1. Shut down the Raspberry Pi.\n2. Insert an SD card flashed with a fresh Raspberry Pi OS Lite (Bookworm).\n3. Boot from the SD card (you may need to set this in raspi-config or the bootloader).\n4. On the SD card OS, run the installer again (curl... | sudo bash install.txt).\n5. Run this TUI again and select 'Maintenance' > 'Expand Filesystem with LVM' to begin Phase 2." 18 75
    elif [[ "$root_dev_full" == /dev/mmcblk* ]]; then
        local boot_drive
        boot_drive=$(echo "$LVM_LOG_FILE" | grep "Source drive:" | tail -1 | awk '{print $3}')
        local boot_type="USB Boot (B2)"
        [[ "$boot_drive" =~ ^nvme ]] && boot_type="NVMe/PCIe Boot (B3)"
        dialog --title "Next Steps: Reboot to LVM" --msgbox "Phase 2 is complete. Please perform the following steps:\n\n1. Shut down the Raspberry Pi.\n2. REMOVE the SD card.\n3. Ensure the boot order is set to '$boot_type' (via raspi-config or bootloader).\n4. Power on the device. It will boot from the new LVM volume.\n5. Once booted, run this TUI again and select 'Maintenance' > 'Expand Filesystem with LVM' to begin the final phase." 18 75
    elif [[ "$root_dev_short" == "rpi--vg-root--lv" ]]; then
        dialog --title "Complete" --yesno "LVM extension is complete! The root filesystem is now extended across both drives. It's recommended to reboot to ensure everything is working correctly. Reboot now?" 10 60
        if [ $? -eq 0 ]; then sudo reboot; fi
    fi

    dialog --title "LVM Extension Log" --textbox "$LVM_LOG_FILE" 25 80
}

# --- Configure Watchdog ---
configure_watchdog() {
    dialog --title "Configure Watchdog" --yesno "This will enable the Raspberry Pi's hardware watchdog to automatically reboot the system if it hangs, improving robustness.\n\nSteps:\n- Add dtparam=watchdog=on to boot config (if not present)\n- Install watchdog package (if not installed)\n- Configure /etc/watchdog.conf\n- Enable and start the watchdog service\n\nA reboot is recommended after configuration.\n\nProceed?" 18 70
    if [ $? -ne 0 ]; then
        return 0
    fi

    local log_file="$LOG_DIR/watchdog_config.log"
    touch "$log_file"
    chmod 644 "$log_file"

    (
        set -euo pipefail
        echo "--- Watchdog Configuration Started at $(date) ---" >> "$log_file"

        # Step 1: Enable hardware watchdog in boot config (idempotent)
        local config_file="$BOOT_PARTITION/config.txt"
        if [ ! -f "$config_file" ]; then
            echo "Error: Boot config file not found at $config_file." >> "$log_file"
            exit 1
        fi
        if ! grep -q "^dtparam=watchdog=on" "$config_file"; then
            echo "dtparam=watchdog=on" >> "$config_file"
            echo "Added dtparam=watchdog=on to $config_file" >> "$log_file"
        else
            echo "dtparam=watchdog=on already present in $config_file" >> "$log_file"
        fi

        # Step 2: Install watchdog package (idempotent)
        apt-get update -y >> "$log_file" 2>&1
        if ! dpkg -s watchdog >/dev/null 2>&1; then
            apt-get install -y watchdog >> "$log_file" 2>&1
            echo "Installed watchdog package" >> "$log_file"
        else
            echo "Watchdog package already installed" >> "$log_file"
        fi

        # Step 3: Configure /etc/watchdog.conf (idempotent)
        local conf_file="/etc/watchdog.conf"
        if [ ! -f "$conf_file" ]; then
            echo "Error: $conf_file not found after installation." >> "$log_file"
            exit 1
        fi
        # Uncomment watchdog-device
        sed -i 's/^#watchdog-device/watchdog-device/' "$conf_file"
        # Add or update other settings
        local settings=(
            "watchdog-timeout = 15"
            "interval = 10"
            "realtime = yes"
        )
        for setting in "${settings[@]}"; do
            local key="${setting%% =*}"
            if grep -q "^$key" "$conf_file"; then
                sed -i "s/^$key.*/$setting/" "$conf_file"
                echo "Updated $key in $conf_file" >> "$log_file"
            else
                echo "$setting" >> "$conf_file"
                echo "Added $setting to $conf_file" >> "$log_file"
            fi
        done

        # Step 4: Enable and start service (idempotent)
        systemctl enable watchdog >> "$log_file" 2>&1 || true
        systemctl start watchdog >> "$log_file" 2>&1 || true
        if systemctl is-active --quiet watchdog; then
            echo "Watchdog service is active" >> "$log_file"
        else
            echo "Error: Failed to start watchdog service" >> "$log_file"
            exit 1
        fi

        echo "--- Watchdog Configuration Completed at $(date) ---" >> "$log_file"
    ) & 
    local pid=$!

    dialog --title "Watchdog Configuration Log" --tailbox "$log_file" 25 80 &
    local tail_pid=$!

    wait $pid
    local exit_code=$?
    kill "$tail_pid" 2>/dev/null || true
    reset_terminal

    if [ $exit_code -eq 0 ]; then
        dialog --title "Success" --msgbox "Watchdog configured successfully. A reboot is required for hardware changes to take effect." 8 60
        dialog --title "Reboot" --yesno "Reboot now?" 8 50
        if [ $? -eq 0 ]; then
            sudo reboot
        fi
    else
        dialog --title "Error" --msgbox "Watchdog configuration failed. Check log at $log_file." 8 60
    fi
}

setup_nextcloud_cron() {
    # Headless guard: Skip checks if called during setup, trust the process
    if [[ -z "${HEADLESS_MODE-}" ]]; then
        if ! is_stack_running; then
            dialog --title "Error" --msgbox "Nextcloud stack is not running." 8 50
            return 1
        fi
    fi

    local nc_cid=$(get_nc_cid)
    # Retry finding container in headless mode as it might be starting up
    if [[ -z "$nc_cid" && -n "${HEADLESS_MODE-}" ]]; then
        sleep 10
        nc_cid=$(get_nc_cid)
    fi
    
    if [[ -z "$nc_cid" ]]; then
        [[ -z "${HEADLESS_MODE-}" ]] && dialog --title "Error" --msgbox "Nextcloud container not found." 8 50
        echo "[WARN] Nextcloud container not found for cron setup." >> "$MAIN_LOG_FILE"
        return 1
    fi

    # In Headless mode, force configuration without prompts
    if [[ -z "${HEADLESS_MODE-}" ]]; then
        local current_mode=$(docker exec -u www-data "$nc_cid" php occ config:app:get core backgroundjobs_mode 2>/dev/null || echo "unknown")
        if [[ "$current_mode" == "cron" ]]; then
            echo "[WARN] Nextcloud cronjob already configured, reconfiguring..." >> "$MAIN_LOG_FILE"
        fi
    fi

    echo "[INFO] Configuring Nextcloud Cron..." >> "$MAIN_LOG_FILE"
    docker exec -u www-data "$nc_cid" php occ background:cron || true

    local cron_content="*/5 * * * * root docker exec -u www-data \$(docker compose -f \"$COMPOSE_FILE\" ps -q nextcloud) php cron.php > /dev/null 2>&1"
    echo "$cron_content" > "$NEXTCLOUD_CRON_FILE"
    chmod 644 "$NEXTCLOUD_CRON_FILE"

    echo "[INFO] Successfully configured Nextcloud Cron" >> "$MAIN_LOG_FILE"
}

disable_wireless() {
    if [[ -z "${HEADLESS_MODE-}" ]]; then
        dialog --title "Disable Wireless" --yesno "This will disable WiFi/Bluetooth.\nProceed?" 10 60
        if [ $? -ne 0 ]; then return 0; fi
    else
        echo "[INFO] Disabling Wireless Interfaces (Headless)..." >> "$MAIN_LOG_FILE"
    fi

    local log_file="$LOG_DIR/wireless_disable.log"
    touch "$log_file"
    chmod 644 "$log_file"

    (
        set -euo pipefail
        echo "--- Wireless Disable Started at $(date) ---" >> "$log_file"

        # Step 1: Add overlays to boot config (idempotent)
        local config_file="$BOOT_PARTITION/config.txt"
        if [ ! -f "$config_file" ]; then
            echo "Error: Boot config file not found at $config_file." >> "$log_file"
            exit 1
        fi
        if ! grep -q "^dtoverlay=disable-wifi" "$config_file"; then
            echo "dtoverlay=disable-wifi" >> "$config_file"
            echo "Added dtoverlay=disable-wifi to $config_file" >> "$log_file"
        else
            echo "dtoverlay=disable-wifi already present in $config_file" >> "$log_file"
        fi
        if ! grep -q "^dtoverlay=disable-bt" "$config_file"; then
            echo "dtoverlay=disable-bt" >> "$config_file"
            echo "Added dtoverlay=disable-bt to $config_file" >> "$log_file"
        else
            echo "dtoverlay=disable-bt already present in $config_file" >> "$log_file"
        fi

        # Step 2: Install rfkill package (idempotent)
        apt-get update -y >> "$log_file" 2>&1
        if ! dpkg -s rfkill >/dev/null 2>&1; then
            apt-get install -y rfkill >> "$log_file" 2>&1
            echo "Installed rfkill package" >> "$log_file"
        else
            echo "rfkill package already installed" >> "$log_file"
        fi

        # Step 3: Immediately block WiFi and Bluetooth
        rfkill block wifi >> "$log_file" 2>&1 || echo "Warning: Failed to block WiFi (may already be disabled)" >> "$log_file"
        rfkill block bluetooth >> "$log_file" 2>&1 || echo "Warning: Failed to block Bluetooth (may already be disabled)" >> "$log_file"
        echo "Blocked WiFi and Bluetooth via rfkill" >> "$log_file"

        # Step 4: Unload modules if loaded (for immediate effect)
        modprobe -r brcmfmac 2>> "$log_file" || true
        modprobe -r hci_uart 2>> "$log_file" || true
        modprobe -r bluetooth 2>> "$log_file" || true
        echo "Unloaded wireless modules if present" >> "$log_file"

        echo "--- Wireless Disable Completed at $(date) ---" >> "$log_file"
    ) & 
    local pid=$!
    local tail_pid=$!

    wait $pid
    local exit_code=$?
    kill "$tail_pid" 2>/dev/null || true
    reset_terminal

    if [ $exit_code -eq 0 ]; then
        echo "[INFO] Success." >> "$MAIN_LOG_FILE"
    else
        echo "[ERROR] during disabling of wireless." >> "$MAIN_LOG_FILE"
    fi
}

# --- Logs Menu ---
logs_menu() {
    while true; do
        local choice
        choice=$(dialog --stdout \
            --title "View Logs" \
            --menu "Select a log to view (or 0 to return):" $HEIGHT $WIDTH $CHOICE_HEIGHT \
            0 "Back to Main Menu" \
            1 "Main Setup Log" \
            2 "Backup Log" \
            3 "Restore Log" \
            4 "Docker Compose Logs" \
            5 "Health Check Log" \
            6 "LVM Migration Log" \
            7 "Flash to Drive Log")
        local retval=$?
        if [ $retval -ne 0 ] || [ "$choice" = "0" ]; then
            return 0
        fi
        
        case "$choice" in
            1) dialog --title "Setup Log" --tailbox "$MAIN_LOG_FILE" 25 80 ;;
            2) dialog --title "Backup Log" --tailbox "$BACKUP_LOG_FILE" 25 80 ;;
            3) dialog --title "Restore Log" --tailbox "$RESTORE_LOG_FILE" 25 80 ;;
            4) 
                local temp_log
                temp_log=$(mktemp)
                if docker compose -f "$COMPOSE_FILE" logs --tail=100 > "$temp_log" 2>&1; then
                    dialog --title "Docker Logs" --tailbox "$temp_log" 25 80
                else
                    dialog --title "Error" --msgbox "Failed to fetch Docker logs." 8 50
                fi
                rm -f "$temp_log"
                ;;
            5) dialog --title "Health Check Log" --tailbox "$HEALTH_LOG_FILE" 25 80 ;;
            6) dialog --title "LVM Log" --tailbox "$LVM_LOG_FILE" 25 80 ;;
            7) dialog --title "Flash Log" --tailbox "$FLASH_LOG_FILE" 25 80 ;;
        esac
        reset_terminal
    done
}

# --- Configure Backup Settings ---
configure_backup_settings() {
    source "$ENV_FILE" 2>/dev/null || true
    local current_retention="${BACKUP_RETENTION:-8}"
    local current_minute="${BACKUP_MINUTE:-0}"
    local current_hour="${BACKUP_HOUR:-3}"
    local current_dom="${BACKUP_DAY_MONTH:-*}"
    local current_month="${BACKUP_MONTH:-*}"
    local current_dow="${BACKUP_DAY_WEEK:-0}"

    # Handle backup drive mounting and configuration
    if mountpoint -q "$BACKUP_MOUNTDIR"; then
        : # Already mounted, proceed
    else
        mount -a >> "$BACKUP_LOG_FILE" 2>&1
        if mountpoint -q "$BACKUP_MOUNTDIR"; then
            : # Mounted successfully, proceed
        else
            dialog --title "Backup Drive" --yesno "Backup drive not mounted. Would you like to configure it now?" 8 60
            if [ $? -eq 0 ]; then
                select_backup_drive || return 0
            else
                dialog --title "Warning" --msgbox "Cannot configure backups without a mounted drive." 8 50
                return 0
            fi
        fi
    fi

    local values
    values=$(dialog --backtitle "Backup Configuration" \
        --stdout \
        --title "Configure Backup Settings" \
        --form "Enter backup settings:" \
        18 60 10 \
        "Retention (Max backups to keep):" 1 1 "$current_retention" 1 20 10 0 \
        "Cron Minute (0-59):" 2 1 "$current_minute" 2 20 10 0 \
        "Cron Hour (0-23):" 3 1 "$current_hour" 3 20 10 0 \
        "Cron Day of Month (1-31):" 4 1 "$current_dom" 4 20 10 0 \
        "Cron Month (1-12):" 5 1 "$current_month" 5 20 10 0 \
        "Cron Day of Week (0-6):" 6 1 "$current_dow" 6 20 10 0)
    local retval=$?
    if [ $retval -ne 0 ] || [ -z "$values" ]; then
        return 0
    fi

    mapfile -t values_array <<< "$values"
    local new_retention="${values_array[0]}"
    local new_minute="${values_array[1]}"
    local new_hour="${values_array[2]}"
    local new_dom="${values_array[3]}"
    local new_month="${values_array[4]}"
    local new_dow="${values_array[5]}"

    update_env "BACKUP_RETENTION" "$new_retention"
    update_env "BACKUP_MINUTE" "$new_minute"
    update_env "BACKUP_HOUR" "$new_hour"
    update_env "BACKUP_DAY_MONTH" "$new_dom"
    update_env "BACKUP_MONTH" "$new_month"
    update_env "BACKUP_DAY_WEEK" "$new_dow"

    install_backup_cron "$new_minute" "$new_hour" "$new_dom" "$new_month" "$new_dow"
}

# --- Run Initial Setup ---
run_initial_setup() {
    # Check if stack is already running (idempotent: warn on re-run)
    if is_stack_running; then
        dialog --title "Warning" --yesno "Stack is already running. Re-run setup? (May reset config)" 8 50
        [[ $? -ne 0 ]] && return
    fi

    local values
    values=$(dialog --backtitle "Nextcloud Initial Setup" \
        --stdout \
        --title "Configuration" \
        --form "Enter your configuration details below." \
        25 60 16 \
        "Admin Password:"   1 1 ""            1 25 40 0 \
        "DB Root Password:" 2 1 ""            2 25 40 0 \
        "DB User Password:" 3 1 ""            3 25 40 0 \
        "Base Domain:"      4 1 "example.com" 4 25 40 0 \
        "Subdomain:"        5 1 "nextcloud"   5 25 40 0)
    local retval=$?
    if [ $retval -ne 0 ] || [ -z "$values" ]; then
        echo "[INFO] User canceled or dialog failed at $(date)" >> "$MAIN_LOG_FILE"
        return 1
    fi

    mapfile -t values_array <<< "$values"
    if [ "${#values_array[@]}" -lt 5 ]; then
        dialog --title "Input Error" --msgbox "All fields are required. Please try again." 8 50
        return 1
    fi

    local ADMIN_PASS="${values_array[0]}"
    local DB_ROOT_PASS="${values_array[1]}"
    local DB_USER_PASS="${values_array[2]}"
    local BASE_DOMAIN="${values_array[3]}"
    local SUBDOMAIN="${values_array[4]}"

    # Safeguard empty vars
    if [[ -z "$ADMIN_PASS" || -z "$DB_ROOT_PASS" || -z "$DB_USER_PASS" || -z "$BASE_DOMAIN" ]]; then
        dialog --title "Input Error" --msgbox "One or more fields are empty. Please try again." 8 50
        return 1
    fi

    # Ensure log file exists and is writable
    touch "$MAIN_LOG_FILE"
    chmod 644 "$MAIN_LOG_FILE"

    # Set variables for setup
    NEXTCLOUD_ADMIN_PASSWORD="$ADMIN_PASS"
    MYSQL_ROOT_PASSWORD="$DB_ROOT_PASS"
    MYSQL_PASSWORD="$DB_USER_PASS"
    BASE_DOMAIN="$BASE_DOMAIN"
    SUBDOMAIN="${SUBDOMAIN:-nextcloud}"

    # Start logging
    {
        set -x
        echo "--- TUI: Setup started at $(date) ---"
    } >> "$MAIN_LOG_FILE" 2>&1

    # Run preflight checks
    echo "[*] Running pre-flight checks..." >> "$MAIN_LOG_FILE" 2>&1
    preflight_checks >> "$MAIN_LOG_FILE" 2>&1

    # Install dependencies
    echo "[1/10] Installing system dependencies..." >> "$MAIN_LOG_FILE" 2>&1
    install_dependencies >> "$MAIN_LOG_FILE" 2>&1

    # Gather config
    echo "[2/10] Gathering configuration from environment..." >> "$MAIN_LOG_FILE" 2>&1
    gather_config_from_env >> "$MAIN_LOG_FILE" 2>&1

    # Consolidated Cloudflare setup - interactive
    echo "[3/10] Setting up Cloudflare Tunnel..." >> "$MAIN_LOG_FILE" 2>&1
    if [ ! -f /root/.cloudflared/cert.pem ]; then
        dialog --msgbox "Cloudflare authentication required. The authentication process will start now." 8 60
        cloudflared tunnel login | dialog --programbox "Cloudflare Authentication - Open the URL in your browser and follow the instructions." 20 80
        if [ ! -f /root/.cloudflared/cert.pem ]; then
            echo "Certificate still not found after login. If running over SSH, the cert.pem was likely downloaded to your local machine." >> "$MAIN_LOG_FILE"
            echo "Please copy cert.pem to /root/.cloudflared/cert.pem on this device and rerun the script." >> "$MAIN_LOG_FILE"
            dialog --title "Error" --msgbox "Missing Cloudflare certificate. If over SSH, copy cert.pem manually to /root/.cloudflared/cert.pem and rerun." 10 70
            return 1
        fi
    fi

    local TUNNEL_NAME="nextcloud-tunnel-$SUBDOMAIN"
    CF_TUNNEL_ID=$(cloudflared tunnel list --output json 2>/dev/null | jq -r ".[] | select(.name==\"$TUNNEL_NAME\") | .id" || true)
    if [[ -n "$CF_TUNNEL_ID" && "$CF_TUNNEL_ID" != "null" ]]; then
        echo "Warning: Tunnel with name $TUNNEL_NAME already exists (ID: $CF_TUNNEL_ID)." >> "$MAIN_LOG_FILE"
        local choice
        choice=$(dialog --stdout --title "Existing Tunnel" --menu "Tunnel exists. Choose action:" 12 60 3 \
            d "Delete and recreate" \
            c "Choose different subdomain" \
            r "Reuse existing")
        if [ $? -ne 0 ]; then return 1; fi
        case "$choice" in
            d)
                echo "Deleting existing tunnel..." >> "$MAIN_LOG_FILE"
                cloudflared tunnel delete "$CF_TUNNEL_ID" >> "$MAIN_LOG_FILE" 2>&1 || {
                    dialog --title "Error" --msgbox "Failed to delete existing tunnel." 8 50
                    return 1
                }
                CF_TUNNEL_ID=""
                ;;
            c)
                SUBDOMAIN=$(dialog --stdout --inputbox "Enter a new subdomain:" 8 50)
                if [ $? -ne 0 ] || [ -z "$SUBDOMAIN" ]; then return 1; fi
                CF_HOSTNAME="$SUBDOMAIN.$BASE_DOMAIN"
                NEXTCLOUD_TRUSTED_DOMAINS="$CF_HOSTNAME"
                TUNNEL_NAME="nextcloud-tunnel-$SUBDOMAIN"
                CF_TUNNEL_ID=$(cloudflared tunnel list --output json 2>/dev/null | jq -r ".[] | select(.name==\"$TUNNEL_NAME\") | .id" || true)
                if [[ -n "$CF_TUNNEL_ID" && "$CF_TUNNEL_ID" != "null" ]]; then
                    dialog --title "Error" --msgbox "Tunnel with new name $TUNNEL_NAME also exists. Please choose another or delete manually." 8 60
                    return 1
                fi
                ;;
            r)
                # Reuse
                ;;
        esac
    fi
    if [[ -z "$CF_TUNNEL_ID" || "$CF_TUNNEL_ID" == "null" ]]; then
        echo "Creating new tunnel: $TUNNEL_NAME" >> "$MAIN_LOG_FILE"
        CF_TUNNEL_ID=$(cloudflared tunnel create "$TUNNEL_NAME" | awk '/Created tunnel/{print $NF}')
        if [ $? -ne 0 ] || [ -z "$CF_TUNNEL_ID" ]; then
            dialog --title "Error" --msgbox "Failed to create tunnel." 8 50
            return 1
        fi
    else
        echo "Reusing existing tunnel ID: $CF_TUNNEL_ID" >> "$MAIN_LOG_FILE"
    fi
    echo "Routing DNS for $CF_HOSTNAME..." >> "$MAIN_LOG_FILE"
    cloudflared tunnel route dns --overwrite-dns "$CF_TUNNEL_ID" "$CF_HOSTNAME" >> "$MAIN_LOG_FILE" 2>&1 || {
        dialog --title "Error" --msgbox "Failed to create or update DNS route for $CF_HOSTNAME." 8 60
        return 1
    }
    local CREDENTIALS_FILE="/root/.cloudflared/${CF_TUNNEL_ID}.json"
    if [[ ! -f "$CREDENTIALS_FILE" ]]; then
        echo "Credentials file missing. Generating by running tunnel temporarily..." >> "$MAIN_LOG_FILE"
        cloudflared tunnel --credentials-file "$CREDENTIALS_FILE" run "$TUNNEL_NAME" & 
        local temp_pid=$!
        sleep 5
        kill "$temp_pid" 2>/dev/null || true
        if [[ ! -f "$CREDENTIALS_FILE" ]]; then
            dialog --title "Error" --msgbox "Failed to generate credentials file." 8 50
            return 1
        fi
    fi
    mkdir -p /etc/cloudflared
    cat > /etc/cloudflared/config.yml <<EOF
tunnel: $TUNNEL_NAME
credentials-file: $CREDENTIALS_FILE
ingress:
  - hostname: $CF_HOSTNAME
    service: http://localhost:$NEXTCLOUD_PORT
  - service: http_status:404
EOF
    cat >/etc/systemd/system/cloudflared.service <<EOF
[Unit]
Description=Cloudflare Tunnel for Nextcloud
After=network-online.target
[Service]
Type=notify
ExecStart=/usr/bin/cloudflared --config /etc/cloudflared/config.yml tunnel run
Restart=on-failure
RestartSec=5s
[Install]
WantedBy=multi-user.target
EOF

    systemctl daemon-reload >> "$MAIN_LOG_FILE" 2>&1
    if systemctl is-enabled --quiet cloudflared 2>/dev/null; then
        echo "[*] Service already enabled, restarting..." >> "$MAIN_LOG_FILE"
        systemctl restart cloudflared >> "$MAIN_LOG_FILE" 2>&1
    else
        echo "[*] Enabling and starting service..." >> "$MAIN_LOG_FILE"
        systemctl enable --now cloudflared >> "$MAIN_LOG_FILE" 2>&1
    fi

    # Generate env file
    echo "[4/10] Generating .env configuration file..." >> "$MAIN_LOG_FILE" 2>&1
    generate_env_file >> "$MAIN_LOG_FILE" 2>&1

    # Deploy stack
    echo "[5/10] Deploying Docker stack..." >> "$MAIN_LOG_FILE" 2>&1
    deploy_docker_stack >> "$MAIN_LOG_FILE" 2>&1

    # Configure HTTPS
    echo "[6/10] Applying reverse proxy HTTPS configuration..." >> "$MAIN_LOG_FILE" 2>&1
    configure_nextcloud_https >> "$MAIN_LOG_FILE" 2>&1

    # Validate
    echo "[10/10] Validating setup..." >> "$MAIN_LOG_FILE" 2>&1
    validate_setup >> "$MAIN_LOG_FILE" 2>&1

    echo "✅ Installation complete!" >> "$MAIN_LOG_FILE" 2>&1

    dialog --title "Setup Log" --tailbox "$MAIN_LOG_FILE" 25 80 &
    local tail_pid=$!

    sleep 1
    kill "$tail_pid" 2>/dev/null || true
    reset_terminal

    dialog --title "Success" --msgbox "Setup completed successfully!" 8 40
}

# --- Run Backup ---
run_backup() {
    if ! is_stack_running; then
        dialog --title "Error" --msgbox "Nextcloud stack not running." 8 50
        return
    fi

    source "$ENV_FILE" 2>/dev/null || true
    dialog --title "Confirm" --yesno "Run backup now? Ensure backup drive is mounted." 8 60
    if [ $? -ne 0 ]; then return; fi

    (
        backup
    ) >> "$BACKUP_LOG_FILE" 2>&1 &
    local pid=$!

    dialog --title "Backup Log" --tailbox "$BACKUP_LOG_FILE" 25 80 &
    local tail_pid=$!

    wait_for_completion "$pid" "Backup in Progress" "Running backup..."
    local exit_code=$?

    kill "$tail_pid" 2>/dev/null || true
    reset_terminal

    if [ $exit_code -eq 0 ]; then
        dialog --title "Success" --msgbox "Backup completed successfully!" 8 40
    else
        dialog --title "Error" --msgbox "Backup failed. Check log at $BACKUP_LOG_FILE." 8 60
    fi
}

# --- Run Restore ---
run_restore() {
    if ! is_stack_running; then
        dialog --title "Error" --msgbox "Nextcloud stack not running." 8 50
        return
    fi

    source "$ENV_FILE" 2>/dev/null || true
    if ! mountpoint -q "$BACKUP_MOUNTDIR"; then
        dialog --title "Error" --msgbox "Backup drive not mounted. Configure in settings first." 8 60
        return
    fi

    local backups
    mapfile -t backups < <(find "$BACKUP_MOUNTDIR" -maxdepth 1 -name 'nextcloud_backup_*.tar.gz' -print0 | xargs -0 ls -t)
    if [ ${#backups[@]} -eq 0 ]; then
        dialog --title "Error" --msgbox "No backups found in $BACKUP_MOUNTDIR." 8 60
        return
    fi

    local options=()
    for i in "${!backups[@]}"; do
        options+=("$((i+1))" "$(basename "${backups[$i]}")")
    done

    local choice
    choice=$(dialog --stdout --title "Select Backup" --menu "Choose a backup to restore:" $HEIGHT $WIDTH $CHOICE_HEIGHT "${options[@]}")
    if [ $? -ne 0 ]; then return; fi

    local selected="${backups[$((choice-1))]}"

    dialog --title "WARNING" --yesno "This will OVERWRITE your current data, config, and database with the contents from $selected.\n\nThis operation is irreversible. Proceed?" 10 70
    if [ $? -ne 0 ]; then return; fi

    (
        restore "$selected" --no-prompt
    ) >> "$RESTORE_LOG_FILE" 2>&1 &
    local pid=$!

    dialog --title "Restore Log" --tailbox "$RESTORE_LOG_FILE" 25 80 &
    local tail_pid=$!

    wait_for_completion "$pid" "Restore in Progress" "Running restore..."
    local exit_code=$?

    kill "$tail_pid" 2>/dev/null || true
    reset_terminal

    if [ $exit_code -eq 0 ]; then
        dialog --title "Success" --msgbox "Restore completed successfully!" 8 40
    else
        dialog --title "Error" --msgbox "Restore failed. Check log at $RESTORE_LOG_FILE." 8 60
    fi
}

# --- Setup FTP Server ---
setup_ftp_server() {
    if [[ $EUID -ne 0 ]]; then
        dialog --title "Error" --msgbox "This option must be run as root." 8 50
        return
    fi

    source "$ENV_FILE" 2>/dev/null || { dialog --title "Error" --msgbox "Environment file not found." 8 50; return; }

    local nc_cid=$(get_nc_cid)
    if [[ -z "$nc_cid" ]]; then
        dialog --title "Error" --msgbox "Nextcloud container not running." 8 50
        return
    fi

    local nc_user
    nc_user=$(dialog --stdout --title "Nextcloud User" --inputbox "Enter the Nextcloud username for FTP access:" 8 50)
    if [ $? -ne 0 ] || [ -z "$nc_user" ]; then return; fi

    # Verify user exists
    if ! docker exec -u www-data "$nc_cid" php occ user:info "$nc_user" >/dev/null 2>&1; then
        dialog --title "Error" --msgbox "Nextcloud user '$nc_user' does not exist." 8 50
        return
    fi

    local ftp_user
    ftp_user=$(dialog --stdout --title "FTP Username" --inputbox "Enter FTP username (default: camera):" 8 50 "camera")
    if [ $? -ne 0 ]; then return; fi
    ftp_user="${ftp_user:-camera}"

    local ftp_pass
    ftp_pass=$(dialog --stdout --title "FTP Password" --passwordbox "Enter FTP password:" 8 50)
    if [ $? -ne 0 ] || [ -z "$ftp_pass" ]; then return; fi

    local confirm_pass
    confirm_pass=$(dialog --stdout --title "Confirm Password" --passwordbox "Confirm FTP password:" 8 50)
    if [ $? -ne 0 ] || [ "$ftp_pass" != "$confirm_pass" ]; then
        dialog --title "Error" --msgbox "Passwords do not match." 8 50
        return
    fi

    dialog --title "Confirm" --yesno "Setup FTP server for user '$nc_user' with FTP user '$ftp_user'? This will install vsftpd and configure it." 10 60
    if [ $? -ne 0 ]; then return; fi

    # Install packages
    apt-get update -y
    apt-get install -y vsftpd libpam-pwdfile apache2-utils inotify-tools

    # Only backup the original conf file if a backup doesn't already exist
    if [ ! -f /etc/vsftpd.conf.bak ]; then
        cp /etc/vsftpd.conf /etc/vsftpd.conf.bak
    fi

    # Set www-data home directory to NEXTCLOUD_DATA_DIR to avoid fallback issues
    if [ "$(getent passwd www-data | cut -d: -f6)" != "$NEXTCLOUD_DATA_DIR" ]; then
        usermod -d "$NEXTCLOUD_DATA_DIR" www-data
    fi

    # Configure vsftpd.conf
    cat > /etc/vsftpd.conf <<EOF
listen=YES
listen_ipv6=NO
local_enable=YES
write_enable=YES
local_umask=022
chroot_local_user=YES
allow_writeable_chroot=YES
guest_enable=YES
guest_username=www-data
virtual_use_local_privs=YES
user_sub_token=\$USER
local_root=${NEXTCLOUD_DATA_DIR}/\$USER/files/uploads
user_config_dir=/etc/vsftpd/user_conf
pam_service_name=vsftpd.virtual
EOF

    # PAM config
    cat > /etc/pam.d/vsftpd.virtual <<EOF
auth    required pam_pwdfile.so pwdfile /etc/vsftpd/ftppasswd
account required pam_permit.so
EOF

    # Create uploads dir
    local upload_dir="${NEXTCLOUD_DATA_DIR}/${nc_user}/files/uploads"
    mkdir -p "$upload_dir"
    chown -R www-data:www-data "${NEXTCLOUD_DATA_DIR}/${nc_user}"

    # Ensure config directory exists before writing to it
    mkdir -p /etc/vsftpd/user_conf

    # Add virtual user (create password file or append to existing)
    if [ ! -f /etc/vsftpd/ftppasswd ]; then
        htpasswd -b -c -d /etc/vsftpd/ftppasswd "$ftp_user" "$ftp_pass"
    else
        htpasswd -b -d /etc/vsftpd/ftppasswd "$ftp_user" "$ftp_pass"
    fi

    # User config for chroot
    echo "local_root=${NEXTCLOUD_DATA_DIR}/${nc_user}/files/uploads" > /etc/vsftpd/user_conf/"$ftp_user"

    # Restart vsftpd
    systemctl restart vsftpd

    # Setup inotify watcher script
    cat > /usr/local/bin/nextcloud-ftp-sync.sh <<EOF
#!/bin/bash

NC_USER="\$1"
WATCH_DIR="${NEXTCLOUD_DATA_DIR}/\$NC_USER/files/uploads"
REPO_DIR="/opt/raspi-nextcloud-setup"
COMPOSE_FILE="\$REPO_DIR/docker-compose.yml"
NC_CID=\$(docker compose -f "\$COMPOSE_FILE" ps -q nextcloud 2>/dev/null || true)
if [[ -z "\$NC_CID" ]]; then exit 1; fi

while true; do
  inotifywait -e create,modify,move,delete -r "\$WATCH_DIR" && \
  docker exec -u www-data "\$NC_CID" php occ files:scan "\$NC_USER"
done
EOF
    chmod +x /usr/local/bin/nextcloud-ftp-sync.sh

    # Systemd service
    cat > /etc/systemd/system/nextcloud-ftp-sync@.service <<EOF
[Unit]
Description=Nextcloud FTP Sync Watcher for %i

[Service]
ExecStart=/usr/local/bin/nextcloud-ftp-sync.sh %i
Restart=always

[Install]
WantedBy=multi-user.target
EOF

    systemctl daemon-reload
    systemctl enable --now nextcloud-ftp-sync@"$nc_user"

    dialog --title "Success" --msgbox "FTP server setup complete. Connect with user '$ftp_user' and password provided. Uploads to '$upload_dir' will trigger Nextcloud scan." 10 70
}

# Injects HA service block into docker-compose.yml
# usage: inject_home_assistant_service <port> <zigbee_device_path|empty>
inject_home_assistant_service() {
    local ha_port="$1"
    local zigbee_device="$2"

    echo "[INFO] Injecting Home Assistant service into compose file..."

    # Normalize: Ensure empty line before 'volumes:' if the line before it is not empty
    awk 'BEGIN {prev=""} {if (/^volumes:/ && prev != "") {print ""} print $0; prev=$0}' "$COMPOSE_FILE" > temp.yml && mv temp.yml "$COMPOSE_FILE"

    # Remove existing HA block if present
    sed -i '/^  homeassistant:/,/^$/d' "$COMPOSE_FILE"

    # Build the HA service block
    local ha_block='  homeassistant:\n    image: homeassistant/home-assistant:stable\n    restart: unless-stopped\n    ports:\n      - "${HA_PORT}:8123"\n    volumes:\n      - ha_config:/config\n    environment:\n      - TZ=Etc/UTC\n    logging:\n      driver: "json-file"\n      options:\n        max-size: "10m"\n        max-file: "3"\n    healthcheck:\n      test: ["CMD", "curl", "-f", "http://localhost:8123"]\n      interval: 30s\n      timeout: 10s\n      retries: 5'

    if [[ -n "$zigbee_device" ]]; then
        ha_block="$ha_block\n    devices:\n      - $zigbee_device:$zigbee_device"
    fi

    ha_block="$ha_block\n"
    ha_block=$(echo -e "$ha_block")

    # Insert the block before 'volumes:'
    awk -v block="$ha_block" '/^volumes:/ { print block } { print }' "$COMPOSE_FILE" > temp.yml && mv temp.yml "$COMPOSE_FILE"

    # Add ha_config to volumes section if not present
    if ! grep -q "^  ha_config:" "$COMPOSE_FILE"; then
        sed -i '/^volumes:/a\  ha_config:' "$COMPOSE_FILE"
    fi

    # Normalize again
    awk 'BEGIN {prev=""} {if (/^volumes:/ && prev != "") {print ""} print $0; prev=$0}' "$COMPOSE_FILE" > temp.yml && mv temp.yml "$COMPOSE_FILE"
}

# Configures Trusted Proxies in Home Assistant configuration.yaml
# usage: configure_ha_proxy_settings <subnet_cidr> <ha_container_id>
configure_ha_proxy_settings() {
    local subnet="$1"
    local cid="$2"

    echo "[INFO] Configuring Home Assistant trusted proxies for subnet: $subnet"

    docker exec "$cid" sh -c "
        CONF='/config/configuration.yaml'
        # 1. Check if the subnet is already trusted
        if grep -Fq '$subnet' \"\$CONF\"; then
            echo 'Subnet already trusted.'
        else
            # 2. Check if trusted_proxies block exists
            if grep -q 'trusted_proxies:' \"\$CONF\"; then
                # Append to existing list
                sed -i '/trusted_proxies:/a \    - $subnet' \"\$CONF\"
            # 3. Check if http block exists but no proxies
            elif grep -q '^http:' \"\$CONF\"; then
                sed -i '/^http:/a \  use_x_forwarded_for: true\n  trusted_proxies:\n    - $subnet' \"\$CONF\"
            # 4. No http block at all
            else
                echo '
http:
  use_x_forwarded_for: true
  trusted_proxies:
    - $subnet
' >> \"\$CONF\"
            fi
        fi
    "
}

setup_home_assistant() {
    source "$ENV_FILE" 2>/dev/null ||
    { dialog --title "Error" --msgbox "Environment file not found. Run Nextcloud setup first." 8 50; return;
    }

    local ha_subdomain
    ha_subdomain=$(dialog --stdout --title "Home Assistant Subdomain" --inputbox "Enter subdomain for Home Assistant (e.g., ha):" 8 50 "ha")
    if [ $? -ne 0 ] || [ -z "$ha_subdomain" ]; then return; fi

    local base_domain="${NEXTCLOUD_TRUSTED_DOMAINS#*.}"
    local ha_hostname="$ha_subdomain.$base_domain"
    local ha_trusted_domains="$ha_hostname"
    local ha_port="${HA_PORT:-8123}"

    # Zigbee dongle selection
    mapfile -t devices < <(ls /dev/ttyUSB* /dev/ttyACM* 2>/dev/null || true)
    local options=("0" "None (skip Zigbee)")
    for i in "${!devices[@]}"; do
        options+=("$((i+1))" "${devices[$i]}")
    done

    local choice
    choice=$(dialog --stdout --title "Select Zigbee Dongle" --menu "Choose the Zigbee dongle device (if any):" $HEIGHT $WIDTH $CHOICE_HEIGHT "${options[@]}")
    if [ $? -ne 0 ]; then return; fi

    local zigbee_device=""
    if [ "$choice" != "0" ]; then
        zigbee_device="${devices[$((choice-1))]}"
    fi

    dialog --title "Confirm" --yesno "Setup Home Assistant on port $ha_port with hostname $ha_hostname? Zigbee: ${zigbee_device:-None}." 10 70
    if [ $? -ne 0 ]; then return; fi

    # Update .env
    update_env "HA_PORT" "$ha_port"
    update_env "HA_TRUSTED_DOMAINS" "$ha_trusted_domains"

    # Reuse Helper Function to modify Compose
    # inject_home_assistant_service "$ha_port" "$zigbee_device"

    # Update Cloudflare Tunnel config (Add ingress rule)
    local tunnel_config="/etc/cloudflared/config.yml"
    if [ -f "$tunnel_config" ]; then
        if grep -q "hostname: $ha_hostname" "$tunnel_config"; then
            sed -i "/hostname: $ha_hostname/,/service:/d" "$tunnel_config"
        fi
        sed -i '/- service: http_status:404/i \  - hostname: '"$ha_hostname"'\n    service: http://localhost:'"$ha_port" "$tunnel_config"
        
        # Route DNS
        local cf_tunnel_id="${CF_TUNNEL_ID:-}"
        if [[ -n "$cf_tunnel_id" ]]; then
             cloudflared tunnel route dns --overwrite-dns "$cf_tunnel_id" "$ha_hostname" || true
             systemctl restart cloudflared
        fi
    fi

    # Deploy
    cd "$REPO_DIR" && docker compose -f "$COMPOSE_FILE" up -d --remove-orphans

    wait_for_healthy "homeassistant" 180 >> "$MAIN_LOG_FILE" 2>&1 || return 1

    # Configure Proxy
    local ha_cid=$(docker compose -f "$COMPOSE_FILE" ps -q homeassistant)
    
    # Detect IP
    curl -s -o /dev/null -H "X-Forwarded-For: 1.2.3.4" "http://localhost:${ha_port}"
    sleep 2
    local log_entry=$(docker logs "$ha_cid" 2>&1 | grep "A request from a reverse proxy was received from" | tail -1)
    
    if [[ -n "$log_entry" ]]; then
        local proxy_ip=$(echo "$log_entry" | sed 's/.*from \([0-9.]\+\),.*/\1/')
        # Reuse Helper Function
        configure_ha_proxy_settings "$proxy_ip" "$ha_cid"
        docker compose -f "$COMPOSE_FILE" restart homeassistant
    wait_for_healthy "homeassistant" 180 >> "$MAIN_LOG_FILE" 2>&1
    fi
    
    # Configure Trust via helper
    configure_docker_subnet_trust
    dialog --title "Success" --msgbox "Home Assistant setup complete." 10 70
}

# --- Setup Pangolin / Newt Headless ---
setup_pangolin_newt_headless() {
    # Non-interactive version
    source "$ENV_FILE"
    echo "Configuring Newt Headless..."
    
    # Inject Newt Block (Idempotent)
    awk 'BEGIN {inside=0} /^  newt:/ {inside=1; next} inside && /^[a-z]/ {inside=0} inside && /^  [a-z]/ {inside=0} inside {next} {print}' "$COMPOSE_FILE" > "${COMPOSE_FILE}.tmp" && mv "${COMPOSE_FILE}.tmp" "$COMPOSE_FILE"
    awk 'BEGIN {prev=""} {if (/^volumes:/ && prev != "") {print ""} print $0; prev=$0}' "$COMPOSE_FILE" > "${COMPOSE_FILE}.tmp" && mv "${COMPOSE_FILE}.tmp" "$COMPOSE_FILE"
    
    local newt_block='  newt:\n    image: fosrl/newt:latest\n    restart: unless-stopped\n    volumes:\n      - /var/run/docker.sock:/var/run/docker.sock:ro\n    environment:\n      - PANGOLIN_ENDPOINT=${PANGOLIN_ENDPOINT}\n      - NEWT_ID=${NEWT_ID}\n      - NEWT_SECRET=${NEWT_SECRET}\n'
    newt_block=$(echo -e "$newt_block")
    
    awk -v block="$newt_block" '/^volumes:/ { print block } { print }' "$COMPOSE_FILE" > "${COMPOSE_FILE}.tmp" && mv "${COMPOSE_FILE}.tmp" "$COMPOSE_FILE"

    # Start the Newt service!
    echo "Starting Newt service..."
    docker compose -f "$COMPOSE_FILE" up -d newt
    
    # Configure Nextcloud trusted domains
    local NC_CID=$(get_nc_cid)
    if [[ -n "$NC_CID" ]]; then
         docker exec --user www-data "$NC_CID" php occ config:system:set trusted_domains 1 --value="$NEXTCLOUD_TRUSTED_DOMAINS" || true
         docker exec --user www-data "$NC_CID" php occ config:system:set overwriteprotocol --value=https || true
         docker exec --user www-data "$NC_CID" php occ config:system:set trusted_proxies 0 --value="$TRUSTED_PROXIES_0" || true
         docker exec --user www-data "$NC_CID" php occ config:system:set trusted_proxies 1 --value="$TRUSTED_PROXIES_1" || true
         docker compose -f "$COMPOSE_FILE" restart nextcloud || true
    fi

    # Configure Home Assistant Trusted Proxies (Headless Requirement #3)
    if grep -q "homeassistant:" "$COMPOSE_FILE"; then
        echo "[INFO] Configuring Home Assistant proxy settings for Pangolin..."
        local ha_cid=$(docker compose -f "$COMPOSE_FILE" ps -q homeassistant)
        if [[ -n "$ha_cid" ]]; then
             # Determine the actual Docker Subnet
             local net_name=$(docker inspect "$ha_cid" --format='{{range $k, $v := .NetworkSettings.Networks}}{{$k}}{{end}}')
             local subnet=$(docker network inspect "$net_name" --format='{{(index .IPAM.Config 0).Subnet}}' 2>/dev/null)
             
             if [[ -z "$subnet" ]]; then
                 subnet="172.16.0.0/12" # Fallback
             fi
             
             # Apply config using reusable helper
             configure_ha_proxy_settings "$subnet" "$ha_cid"
             
             docker compose -f "$COMPOSE_FILE" restart homeassistant || true
             echo "[INFO] Home Assistant proxy configured."
        fi
    fi
}

run_headless_setup(){
    echo "Starting Headless Setup..." > "$MAIN_LOG_FILE"
    
    # 1. Load Environment (Pre-populated by Python)
    if [[ -f "$ENV_FILE" ]];
    then
        source "$ENV_FILE"
    else
        die "Environment file not found for headless setup."
    fi
    
    # 2. Run Dependencies & Config
    export HEADLESS_MODE=true 
    preflight_checks >> "$MAIN_LOG_FILE" 2>&1
    install_dependencies >> "$MAIN_LOG_FILE" 2>&1
    generate_env_template

    # 3. Gather Config (but respect existing .env values)
    gather_config_from_env >> "$MAIN_LOG_FILE" 2>&1
    generate_env_file >> "$MAIN_LOG_FILE" 2>&1
    
    # 5. Deploy Stack
    deploy_docker_stack >> "$MAIN_LOG_FILE" 2>&1

    wait_for_nextcloud_install >> "$MAIN_LOG_FILE" 2>&1 || die "Installation failed."
    
    # 6. Configure Tunnels (Pangolin or Cloudflare based on env)
    update_tunnel_services >> "$MAIN_LOG_FILE" 2>&1

    # 7. Hardening & Configuration
    echo "[7/10] Configuring system hardening..." >> "$MAIN_LOG_FILE"
    setup_nextcloud_cron >> "$MAIN_LOG_FILE" 2>&1
    disable_wireless >> "$MAIN_LOG_FILE" 2>&1
    
    # 8. Finish
    touch "$REPO_DIR/.setup_complete"
    echo "✅ Installation complete!" >> "$MAIN_LOG_FILE"
    exit 0
}

# --- Argument Parsing for Non-Interactive Modes (e.g., cron) ---
if [ $# -gt 0 ]; then
    case "$1" in
        --backup) backup; exit $? ;;
        --restore) shift; restore "$@"; exit $? ;;
        --headless) run_headless_setup; exit $? ;;
        --update-tunnels) update_tunnel_services; exit $? ;; # New Flag
    esac
fi

# --- Main Menu ---
main_menu() {
    while true; do
        local choice
        choice=$(dialog --stdout \
            --backtitle "Raspi Nextcloud TUI" \
            --title "Main Menu" \
            --menu "Select an option:" $HEIGHT $WIDTH $CHOICE_HEIGHT \
            1 "Initial Nextcloud+Cloudflare Setup" \
            2 "Run Backup" \
            3 "Run Restore" \
            4 "Configure Backup Settings" \
            5 "System Health Check" \
            6 "Maintenance Menu" \
            7 "View Logs" \
            8 "Setup FTP Server" \
            9 "Setup Home Assistant" \
            10 "Setup Pangolin/Newt Tunnel" \
            0 "Exit")
        local retval=$?
        if [ $retval -ne 0 ] || [ "$choice" = "0" ]; then
            clear; exit 0
        fi
        case "$choice" in
            1) run_initial_setup ;;
            2) run_backup ;;
            3) run_restore ;;
            4) configure_backup_settings ;;
            5) system_health_check; dialog --title "System Health Check" --textbox "$HEALTH_LOG_FILE" 25 80 ;;
            6) maintenance_menu ;;
            7) logs_menu ;;
            8) setup_ftp_server ;;
            9) setup_home_assistant ;;
            10) setup_pangolin_newt ;;
        esac
        reset_terminal
    done
}

# --- Script Entrypoint ---
cd "$REPO_DIR" || { echo "Error: Cannot access $REPO_DIR"; exit 1; }
main_menu