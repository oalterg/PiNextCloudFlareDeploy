#!/bin/bash
set -euo pipefail

# Load Common Library
SCRIPT_DIR="$(dirname "$(readlink -f "$0")")"
source "$SCRIPT_DIR/common.sh"

# Global Config
VSFTPD_CONF="/etc/vsftpd.conf"
FTP_PASSWD_FILE="/etc/vsftpd/ftppasswd"
USER_CONFIG_DIR="/etc/vsftpd/user_conf"
BOOT_CONFIG="/boot/firmware/config.txt"
WATCHDOG_CONF="/etc/watchdog.conf"
NC_CRON_FILE="/etc/cron.d/nextcloud-cron"

# --- Helper: Configure Watchdog ---
configure_watchdog() {
    local action="$1" # enable | disable

    if [[ "$action" == "enable" ]]; then
        log_info "Enabling System Watchdog..."
        
        # 1. Boot Config (Idempotent)
        if ! grep -q "^dtparam=watchdog=on" "$BOOT_CONFIG"; then
            # Ensure we don't append to a line without newline
            sed -i '$a dtparam=watchdog=on' "$BOOT_CONFIG"
            log_info "Added dtparam=watchdog=on to config.txt"
        fi

        # 2. Install Package
        if ! dpkg -s watchdog >/dev/null 2>&1; then
            export DEBIAN_FRONTEND=noninteractive
            apt-get update -qq && apt-get install -y -qq watchdog
        fi

        # 3. Configure Service
        if [[ -f "$WATCHDOG_CONF" ]]; then
            sed -i 's/^#watchdog-device/watchdog-device/' "$WATCHDOG_CONF"
            sed -i 's/^#max-load-1/max-load-1/' "$WATCHDOG_CONF"
            # Ensure critical settings
            if ! grep -q "watchdog-timeout" "$WATCHDOG_CONF"; then
                echo "watchdog-timeout = 15" >> "$WATCHDOG_CONF"
            fi
        fi

        # 4. Enable Service
        systemctl enable --now watchdog
        log_info "Watchdog enabled and started."

    elif [[ "$action" == "disable" ]]; then
        log_info "Disabling System Watchdog..."
        systemctl disable --now watchdog
        # We generally leave the boot config alone to avoid reboot friction, 
        # but stopping the service is sufficient.
    fi
}

# --- Helper: Configure Nextcloud Cron ---
configure_nc_cron() {
    local nc_cid=$(get_nc_cid)
    if [[ -z "$nc_cid" ]]; then die "Nextcloud container not running."; fi

    log_info "Configuring Nextcloud system cron..."
    
    # 1. Set mode in Nextcloud
    docker exec -u www-data "$nc_cid" php occ background:cron || true

    # 2. Write System Cron file
    # Uses dynamic container ID lookup inside the cron command for robustness across restarts
    cat > "$NC_CRON_FILE" <<EOF
# Generated by HomeBrain Manager
*/5 * * * * root docker exec -u www-data \$(docker compose -f $COMPOSE_FILE ps -q nextcloud) php cron.php > /dev/null 2>&1
EOF
    chmod 644 "$NC_CRON_FILE"
    systemctl restart cron
    
    log_info "Nextcloud cron configured."
}

# --- Helper: Configure PCIe Speed ---
configure_pci_speed() {
    local speed="$1" # gen2 | gen3
    
    if [[ "$speed" == "gen3" ]]; then
        log_info "Enabling PCIe Gen 3.0 speeds..."
        if ! grep -q "^dtparam=pciex1_gen=3" "$BOOT_CONFIG"; then
             sed -i '$a dtparam=pciex1_gen=3' "$BOOT_CONFIG"
             log_info "Gen 3 enabled. Reboot required."
        fi
    else
        log_info "Reverting to PCIe Gen 2.0 (Default)..."
        sed -i '/^dtparam=pciex1_gen=3/d' "$BOOT_CONFIG"
    fi
}

# --- Status Checks (JSON Output) ---
get_system_config_status() {
    # Watchdog
    local wd_status="disabled"
    if systemctl is-active --quiet watchdog; then wd_status="enabled"; fi

    # PCIe
    local pci_status="gen2"
    if grep -q "^dtparam=pciex1_gen=3" "$BOOT_CONFIG"; then pci_status="gen3"; fi

    # NC Cron
    local cron_status="unknown"
    local nc_cid=$(get_nc_cid)
    if [[ -n "$nc_cid" ]]; then
        cron_status=$(docker exec -u www-data "$nc_cid" php occ config:app:get core backgroundjobs_mode 2>/dev/null || echo "unknown")
    fi

    # Return JSON
    echo "{\"watchdog\": \"$wd_status\", \"pci\": \"$pci_status\", \"cron\": \"$cron_status\"}"
}

# --- Helper: Install Dependencies ---
ensure_ftp_dependencies() {
    if ! command -v vsftpd >/dev/null 2>&1; then
        log_info "Installing VSFTPD and utilities..."
        export DEBIAN_FRONTEND=noninteractive
        apt-get update -qq
        apt-get install -y -qq vsftpd libpam-pwdfile apache2-utils inotify-tools
    fi
}

# --- Helper: Configure VSFTPD ---
configure_vsftpd() {
    load_env
    
    # Backup original if not done
    if [ ! -f "${VSFTPD_CONF}.bak" ]; then
        cp "$VSFTPD_CONF" "${VSFTPD_CONF}.bak"
    fi

    # Fix www-data home for chroot compatibility (Idempotent)
    local www_home
    www_home=$(getent passwd www-data | cut -d: -f6)
    if [ "$www_home" != "$NEXTCLOUD_DATA_DIR" ]; then
        log_info "Updating www-data home directory to $NEXTCLOUD_DATA_DIR..."
        usermod -d "$NEXTCLOUD_DATA_DIR" www-data
    fi

    # Write Config (Hardened)
    cat > "$VSFTPD_CONF" <<EOF
listen=YES
listen_ipv6=NO
local_enable=YES
write_enable=YES
local_umask=022
chroot_local_user=YES
allow_writeable_chroot=YES
guest_enable=YES
guest_username=www-data
virtual_use_local_privs=YES
user_sub_token=\$USER
local_root=${NEXTCLOUD_DATA_DIR}/\$USER/files/uploads
user_config_dir=${USER_CONFIG_DIR}
pam_service_name=vsftpd.virtual
pasv_min_port=40000
pasv_max_port=50000
EOF

    # Configure PAM
    if ! grep -q "pam_pwdfile.so" /etc/pam.d/vsftpd.virtual 2>/dev/null; then
        cat > /etc/pam.d/vsftpd.virtual <<EOF
auth    required pam_pwdfile.so pwdfile ${FTP_PASSWD_FILE}
account required pam_permit.so
EOF
    fi

    mkdir -p "$USER_CONFIG_DIR"
}

# --- Action: Setup FTP User ---
setup_ftp_user() {
    local nc_user="$1"
    local ftp_user="$2"
    local ftp_pass="$3"

    load_env
    ensure_ftp_dependencies
    configure_vsftpd

    # 1. Verify Nextcloud User
    local nc_cid=$(get_nc_cid)
    if [[ -z "$nc_cid" ]]; then die "Nextcloud container is not running."; fi
    
    if ! docker exec -u www-data "$nc_cid" php occ user:info "$nc_user" >/dev/null 2>&1; then
        die "Nextcloud user '$nc_user' does not exist."
    fi

    # 2. Create Upload Directory
    local upload_dir="${NEXTCLOUD_DATA_DIR}/${nc_user}/files/uploads"
    if [ ! -d "$upload_dir" ]; then
        log_info "Creating upload directory: $upload_dir"
        mkdir -p "$upload_dir"
        chown -R www-data:www-data "$upload_dir"
    fi

    # 3. Add/Update Virtual FTP User
    # Use -B to verify bcrypt compatibility if needed, but md5 (-d) is standard for pam_pwdfile
    if [ ! -f "$FTP_PASSWD_FILE" ]; then
        htpasswd -b -c -d "$FTP_PASSWD_FILE" "$ftp_user" "$ftp_pass"
    else
        htpasswd -b -d "$FTP_PASSWD_FILE" "$ftp_user" "$ftp_pass"
    fi

    # 4. Map FTP User to NC User Directory
    # We store the NC user in a comment for the API to read back later
    echo "# NC_USER=${nc_user}" > "${USER_CONFIG_DIR}/${ftp_user}"
    echo "local_root=${NEXTCLOUD_DATA_DIR}/${nc_user}/files/uploads" >> "${USER_CONFIG_DIR}/${ftp_user}"

    # 5. Setup Watcher Service (inotify)
    local service_name="nextcloud-ftp-sync@${nc_user}"
    local watcher_script="/usr/local/bin/nextcloud-ftp-sync.sh"
    
    # Create robust watcher script
    cat > "$watcher_script" <<EOF
#!/bin/bash
NC_USER="\$1"
WATCH_DIR="${NEXTCLOUD_DATA_DIR}/\$NC_USER/files/uploads"
# Wait for Docker
until docker info >/dev/null 2>&1; do sleep 5; done

while true; do
  # Wait for file events
  inotifywait -e close_write,moved_to,create -r "\$WATCH_DIR"
  
  # Trigger Scan (debounce slightly)
  sleep 2
  NC_CID=\$(docker compose -f "${COMPOSE_FILE}" ps -q nextcloud 2>/dev/null)
  if [[ -n "\$NC_CID" ]]; then
      echo "Scanning files for \$NC_USER..."
      docker exec -u www-data "\$NC_CID" php occ files:scan --path="/\$NC_USER/files/uploads"
  fi
done
EOF
    chmod +x "$watcher_script"

    # Create/Enable Systemd Service template
    if [ ! -f /etc/systemd/system/nextcloud-ftp-sync@.service ]; then
        cat > /etc/systemd/system/nextcloud-ftp-sync@.service <<EOF
[Unit]
Description=Nextcloud FTP Sync Watcher for %i
After=docker.service

[Service]
ExecStart=$watcher_script %i
Restart=always
RestartSec=10

[Install]
WantedBy=multi-user.target
EOF
        systemctl daemon-reload
    fi

    systemctl enable --now "$service_name"
    systemctl restart vsftpd
    
    log_info "FTP User '$ftp_user' mapped to Nextcloud user '$nc_user' successfully."
}

# --- Action: Delete FTP User ---
delete_ftp_user() {
    local ftp_user="$1"
    
    if [ -f "$FTP_PASSWD_FILE" ]; then
        htpasswd -D "$FTP_PASSWD_FILE" "$ftp_user"
    fi
    
    if [ -f "${USER_CONFIG_DIR}/${ftp_user}" ]; then
        rm "${USER_CONFIG_DIR}/${ftp_user}"
    fi
    
    # Note: We do NOT stop the sync service because multiple FTP users might map to the same NC user.
    # Service cleanup is left manual or handled by a deeper logic if needed.
    
    systemctl restart vsftpd
    log_info "FTP User '$ftp_user' deleted."
}

# --- Action: Activate Tunnels (Post-Setup) ---
activate_tunnels() {
    log_info "Initializing Tunnel Activation..."
    load_env
    
    local profiles=$(get_tunnel_profiles)
    
    if [[ -z "$profiles" ]]; then
        log_info "No tunnel profiles configured (Local Mode). Skipping activation."
    else
        log_info "Activating tunnel profiles: $profiles"
        docker compose --env-file "$ENV_FILE" $(get_compose_args) $profiles up -d --remove-orphans
        log_info "Tunnel services started."
    fi
}

create_ha_admin() {
    local HA_PASSWORD="$1"
    if [ -z "$HA_PASSWORD" ]; then
        die "HA_PASSWORD not provided to utility."
    fi

    # Use the built-in health check helper first
    # This ensures the container is actually running before we spam the API
    wait_for_healthy "homeassistant" 120 || { log_error "HA container not healthy"; return 1; }

    log_info "Creating Home Assistant Admin Account..."
    local HA_URL="http://127.0.0.1:8123"
    local CLIENT_ID="$HA_URL/"  # Use actual HA URL for client_id (per docs/examples)

    # 1. Wait for API readiness (container health != API ready)
    local retries=60  # Wait up to ~2min
    local api_ready=false
    local status
    while [[ $retries -gt 0 ]]; do
        status=$(curl -s -o /dev/null -w "%{http_code}" --max-time 10 "$HA_URL/api/onboarding")
        if [[ "$status" == "200" ]]; then
            api_ready=true
            break
        fi
        sleep 2
        ((retries--))
    done

    if [ "$api_ready" = false ]; then
        log_warn "Home Assistant onboarding API did not become ready after 2min. Account creation skipped."
        return 1
    fi

    # 2. Check if onboarding is still needed (robust jq parsing)
    local onboarding_status=$(curl -s --max-time 10 "$HA_URL/api/onboarding")
    log_info "Onboarding status response: $onboarding_status"
    local user_done
    user_done=$(echo "$onboarding_status" | jq '.[] | select(.step == "user") | .done // false' 2>/dev/null) || user_done="false"
    if [[ "$user_done" == "true" ]]; then
        log_info "Home Assistant user onboarding already complete. Skipping account creation."
        return 0
    fi

    # 3. Create user account
    log_info "Creating 'admin' user..."
    local output=$(curl -s -w "\n%{http_code}" -X POST --max-time 10 \
        -H "Content-Type: application/json" \
        -d "{\"name\": \"Admin\", \"username\": \"admin\", \"password\": \"$HA_PASSWORD\", \"language\": \"en\", \"client_id\": \"$CLIENT_ID\"}" \
        "$HA_URL/api/onboarding/users")
    local response=$(echo "$output" | head -n -1)
    local http_code=$(echo "$output" | tail -n1)
    
    log_info "User creation raw response: $response (HTTP: $http_code)"

    if [[ $http_code -ne 200 && $http_code -ne 201 ]]; then
        log_warn "User creation failed with HTTP $http_code. Response: $response"
        return 1
    fi

    # Parse auth_code (used in modern HA)
    local auth_code=$(echo "$response" | jq -r '.auth_code // empty')
    if [[ -z "$auth_code" ]]; then
        log_warn "Failed to create HA user. API did not return an auth_code. Raw response: $response"
        return 1
    fi

    # 4. Exchange auth_code for access_token (required for further onboarding)
    local token_output=$(curl -s -w "\n%{http_code}" -X POST --max-time 10 \
        -H "Content-Type: application/x-www-form-urlencoded" \
        -d "grant_type=authorization_code&code=$auth_code&client_id=$CLIENT_ID" \
        "$HA_URL/auth/token")
    local token_response=$(echo "$token_output" | head -n -1)
    local token_http_code=$(echo "$token_output" | tail -n1)
    
    if [[ $token_http_code -ne 200 ]]; then
        log_warn "Token exchange failed with HTTP $token_http_code. Response: $token_response"
        return 1
    fi
    
    local access_token=$(echo "$token_response" | jq -r '.access_token // empty')
    if [[ -z "$access_token" ]]; then
        log_warn "Failed to exchange auth_code for access_token. Raw response: $token_response"
        return 1
    fi

    # 5. Complete core_config onboarding step (minimal required post-user)
    local core_output=$(curl -s -w "\n%{http_code}" -X POST --max-time 10 \
        -H "Authorization: Bearer $access_token" \
        -H "Content-Type: application/json" \
        -d "{}" \
        "$HA_URL/api/onboarding/core_config")
    local core_response=$(echo "$core_output" | head -n -1)
    local core_http_code=$(echo "$core_output" | tail -n1)
    
    if [[ $core_http_code -ne 200 ]]; then
        log_warn "Core config failed with HTTP $core_http_code. Response: $core_response"
        return 1
    fi
    
    if [[ -z "$core_response" || "$core_response" != "{}" ]]; then  # Empty {} indicates success
        log_warn "Failed to complete core_config. Raw response: $core_response"
        return 1
    fi

    # 6. Verify overall onboarding (optional hardening: re-check status)
    onboarding_status=$(curl -s --max-time 10 "$HA_URL/api/onboarding")
    log_info "Post-onboarding status response: $onboarding_status"
    user_done=$(echo "$onboarding_status" | jq '.[] | select(.step == "user") | .done // false' 2>/dev/null) || user_done="false"
    local core_done=$(echo "$onboarding_status" | jq '.[] | select(.step == "core_config") | .done // false' 2>/dev/null) || core_done="false"
    if [[ "$user_done" != "true" || "$core_done" != "true" ]]; then
        log_warn "Onboarding verification failed post-creation. User done: $user_done, Core done: $core_done"
        return 1
    fi

    log_info "Home Assistant admin user created and minimal onboarding completed successfully."
    return 0
}

# --- Main Dispatch ---
case "${1:-}" in
    system_status)
        get_system_config_status
        ;;
    watchdog)
        configure_watchdog "${2}"
        ;;
    cron)
        configure_nc_cron
        ;;
    pci)
        configure_pci_speed "${2}"
        ;;
    redis_status)
        nc_cid=$(get_nc_cid)
        # Robustness: Check if container exists AND is actually running
        if [[ -z "$nc_cid" ]] || [[ $(docker inspect -f '{{.State.Running}}' "$nc_cid" 2>/dev/null) != "true" ]]; then
             echo "disconnected"
             exit 0
        fi

        # Check if the 'host' value in Nextcloud config is set to 'redis'
        host_val=$(docker exec --user www-data "$nc_cid" php occ config:system:get redis host 2>/dev/null || echo "")
        
        if [[ "$host_val" == "redis" ]]; then
            echo "connected"
        else
            echo "unconfigured"
        fi
        ;;
    redis_configure)
        configure_nextcloud_redis
        ;;
    setup)
        setup_ftp_user "${2}" "${3}" "${4}"
        ;;
    delete)
        delete_ftp_user "${2}"
        ;;
    activate_tunnels)
        activate_tunnels
        ;;
    ha_admin)
        create_ha_admin "${2:-}"
        ;;
    *)
        echo "Usage: $0 {setup <nc_user> <ftp_user> <ftp_pass> | delete <ftp_user>}"
        exit 1
        ;;
esac